"""
SISTEMA DE PROGRAMACI√ìN DE SE√ëALES Y NOTIFICACIONES
Maneja:
- Programaci√≥n de se√±ales (8:00 AM - 8:00 PM, Lun-S√°b)
- M√≠nimo 20-25 se√±ales por d√≠a
- Notificaciones pre-se√±al
- Mensajes motivacionales
- Res√∫menes diarios
- An√°lisis de rendimiento
"""

import asyncio
import json
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import random
import pandas as pd
from .market_manager import MarketManager
from .user_manager import UserManager

class SignalScheduler:
    def __init__(self):
        self.market_manager = None  # Se configurar√° externamente
        self.user_manager = None  # Se configurar√° externamente
        self.se√±ales_programadas = []
        self.se√±ales_enviadas_hoy = []
        self.objetivo_se√±ales_diarias = 25
        self.mercado_actual = None
        self.bot_telegram = None  # Se configurar√° externamente
        self.frases_motivacionales = self.cargar_frases_motivacionales()
        self.running = False
        # Override temporal de horario operativo (si est√° activo, se ignoran reglas de horario)
        self._override_until: Optional[datetime] = None
        # Almacenamiento de confirmaciones/IDs activos
        self.pre_id_actual: Optional[str] = None
        self.signal_id_actual: Optional[str] = None
        self.senales_pendientes: Dict[str, Dict] = {}
        # Ventanas de caducidad
        self.pre_ttl_min = 2  # minutos para aceptar pre‚Äëse√±al
        self.signal_ttl_min = 2  # minutos para aceptar se√±al
        self._pre_expirations: Dict[str, datetime] = {}
        self._signal_expirations: Dict[str, datetime] = {}
        # Estado de conexi√≥n/pausa
        self.pausado_por_conexion: bool = False
        self._monitor_task = None

    def configurar_bot_telegram(self, bot_telegram):
        """Inyecta la referencia del bot de Telegram para enviar confirmaciones."""
        try:
            self.bot_telegram = bot_telegram
            print("[SignalScheduler] ü§ù Bot de Telegram configurado para confirmaciones")
        except Exception as e:
            print(f"[SignalScheduler] ‚ùå No se pudo configurar bot de Telegram: {e}")
        # Iniciar monitor de conexi√≥n si no est√° activo
        try:
            if self._monitor_task is None or self._monitor_task.done():
                import asyncio as _aio
                self._monitor_task = _aio.create_task(self.monitor_conexion_quotex())
                print("[SignalScheduler] ü©∫ Monitor de conexi√≥n a Quotex iniciado")
        except Exception as e:
            print(f"[SignalScheduler] ‚ö†Ô∏è No se pudo iniciar monitor de conexi√≥n: {e}")
        
    def cargar_frases_motivacionales(self) -> Dict:
        """Carga las frases motivacionales categorizadas"""
        return {
            # Frases para inicio del d√≠a (mensaje 15 min antes de las 8:00 AM)
            'bienvenida_diaria': [
                "No viniste a probar suerte‚Ä¶ viniste a dominar el juego.",
                "La paciencia y la l√≥gica siempre vencen al impulso.",
                "Cada vela cuenta una historia‚Ä¶ t√∫ decides c√≥mo leerla.",
                "No se trata de predecir, se trata de entender.",
                "Tu mejor operaci√≥n es la que sigue tu an√°lisis, no tu emoci√≥n.",
                "El mercado premia la disciplina, no la desesperaci√≥n.",
                "Cuando los dem√°s dudan, t√∫ operas con visi√≥n.",
                "Los errores ense√±an, pero la constancia gana.",
                "No es suerte si lo entrenaste 100 veces antes.",
                "Operar sin l√≥gica es como navegar sin mapa.",
                "No esperes la se√±al perfecta‚Ä¶ constr√∫yela.",
                "Con control, enfoque y paciencia: no pierdes, aprendes.",
                "La estrategia no es magia: es an√°lisis + ejecuci√≥n.",
                "Cada pullback es una oportunidad, si sabes verlo.",
                "El mercado es tu campo de batalla, el an√°lisis es tu arma."
            ],
            
            # Frases para usuarios que se conectan temprano
            'bienvenida_temprana': [
                "Los que esperan la se√±al perfecta, nunca ganan. Los que entienden el juego, la construyen.",
                "La disciplina de hoy es la ganancia de ma√±ana.",
                "Cada d√≠a es una nueva oportunidad de demostrar tu control.",
                "El √©xito no llega por casualidad, llega por preparaci√≥n.",
                "Hoy puede ser tu mejor d√≠a si operas con la mente, no con el coraz√≥n."
            ],
            
            # Frases para respuesta autom√°tica a nuevos usuarios
            'saludo_automatico': [
                "No viniste a probar suerte‚Ä¶ viniste a dominar el juego.",
                "La paciencia y la l√≥gica siempre vencen al impulso.",
                "Cada vela cuenta una historia‚Ä¶ t√∫ decides c√≥mo leerla.",
                "No se trata de predecir, se trata de entender.",
                "Tu mejor operaci√≥n es la que sigue tu an√°lisis, no tu emoci√≥n.",
                "El mercado premia la disciplina, no la desesperaci√≥n.",
                "Cuando los dem√°s dudan, t√∫ operas con visi√≥n.",
                "Los errores ense√±an, pero la constancia gana.",
                "No es suerte si lo entrenaste 100 veces antes.",
                "Operar sin l√≥gica es como navegar sin mapa.",
                "No esperes la se√±al perfecta‚Ä¶ constr√∫yela.",
                "Con control, enfoque y paciencia: no pierdes, aprendes.",
                "La estrategia no es magia: es an√°lisis + ejecuci√≥n.",
                "Cada pullback es una oportunidad, si sabes verlo.",
                "El mercado es tu campo de batalla, el an√°lisis es tu arma."
            ],
            
            # Frases para cierre exitoso (>80% efectividad)
            'cierre_exitoso': [
                "Hoy no ganaste por suerte, ganaste porque tu an√°lisis fue m√°s fuerte.",
                "Cuando aplicas la l√≥gica y la paciencia, el mercado responde.",
                "Hoy dominaste el juego‚Ä¶ ma√±ana toca repetir la f√≥rmula.",
                "Disciplina + estrategia = resultados. Hoy lo comprobaste.",
                "El que entiende las velas, no necesita adivinarlas.",
                "Hoy fuiste preciso, enfocado y controlado. As√≠ se gana.",
                "Cada decisi√≥n con l√≥gica te acerc√≥ a este resultado. Bien hecho.",
                "Los resultados de hoy confirman que est√°s operando con mentalidad de trader.",
                "Cuando tus decisiones siguen un plan, los n√∫meros responden.",
                "Hoy fuiste m√°s que trader: fuiste estratega.",
                "No es magia. Es l√≥gica, estudio y ejecuci√≥n.",
                "Hoy el mercado habl√≥‚Ä¶ y t√∫ supiste escuchar."
            ],
            
            # Frases para d√≠a estable (60-80% efectividad)
            'cierre_estable': [
                "Un buen d√≠a no es perfecto, es disciplinado.",
                "El enfoque que tuviste hoy construye la consistencia de ma√±ana.",
                "No todos los d√≠as traen gloria, pero todos construyen experiencia.",
                "Hoy sumaste decisiones con l√≥gica. Esa es la verdadera ganancia.",
                "Sigue afinando tu visi√≥n, cada d√≠a suma al trader que est√°s formando.",
                "La suerte es solo el reflejo de la disciplina repetida cada d√≠a.",
                "Hoy fuiste m√°s fuerte que la emoci√≥n. Ma√±ana, m√°s sabio que ayer.",
                "Las velas no se controlan‚Ä¶ pero tu reacci√≥n a ellas, s√≠.",
                "Pierdas o ganes, lo importante es seguir el plan. La consistencia construye resultados.",
                "El que entiende el juego, no necesita suerte."
            ],
            
            # Frases para d√≠a dif√≠cil (<60% efectividad)
            'cierre_dificil': [
                "El mercado no siempre premia, pero siempre ense√±a.",
                "Hoy no ganaste dinero‚Ä¶ pero ganaste experiencia. Ma√±ana la conviertes en resultados.",
                "Hasta los mejores traders tienen d√≠as rojos. Lo que los hace grandes es que siguen.",
                "Perder no significa fallar, sino que est√°s un paso m√°s cerca de dominar el sistema.",
                "No es un mal d√≠a‚Ä¶ es un buen maestro disfrazado.",
                "Hoy fue duro, pero no olvides que tu disciplina no depende del resultado.",
                "No midas tu progreso por un solo d√≠a. Mira el camino completo.",
                "A veces el mercado ense√±a con golpes. Apr√©ndelo y sigue.",
                "Un d√≠a malo no define tu futuro. Tu constancia s√≠.",
                "Hoy no ganaste‚Ä¶ pero no perdiste si aprendiste.",
                "El retroceso de hoy es el impulso de ma√±ana.",
                "En el trading, el control emocional vale m√°s que una se√±al perfecta."
            ],
            
            # Frases para se√±ales exitosas
            'se√±al_exitosa': [
                "¬°Excelente! Esa fue una ejecuci√≥n perfecta.",
                "¬°Genial! El an√°lisis fue preciso.",
                "¬°Perfecto! As√≠ se hace trading profesional."
            ],
            'fin_dia_bueno': [
                "¬°Buen trabajo equipo! üëè ¬°D√≠a s√≥lido de trading!",
                "¬°Excelente! üìà ¬°Otro d√≠a positivo!",
                "¬°Bien hecho! üí™ ¬°Seguimos creciendo!",
                "¬°Genial! ‚≠ê ¬°Consistencia que da frutos!",
                "¬°Perfecto! üéØ ¬°D√≠a productivo completado!"
            ],
            'fin_dia_regular': [
                "¬°D√≠a completado! üìä ¬°Ma√±ana ser√° mejor!",
                "¬°Bien! üëç ¬°Cada d√≠a aprendemos m√°s!",
                "¬°Adelante! üö∂‚Äç‚ôÇÔ∏è ¬°El progreso es constante!",
                "¬°Continuamos! üìà ¬°La consistencia es clave!",
                "¬°Seguimos! üí™ ¬°Cada d√≠a nos hace m√°s fuertes!"
            ],
            'motivacion_general': [
                "¬°El √©xito est√° en los detalles! üîç",
                "¬°La disciplina es tu mejor aliada! üí™",
                "¬°Cada p√©rdida es una lecci√≥n! üìö",
                "¬°La paciencia es la clave del trading! ‚è∞",
                "¬°Conf√≠a en el proceso! üéØ"
            ]
        }

    # ==== Expiraci√≥n de pre‚Äëse√±al y se√±al ====
    def set_pre_expiration(self, pre_id: str, ttl_min: Optional[int] = None):
        ttl = ttl_min if ttl_min is not None else self.pre_ttl_min
        self._pre_expirations[pre_id] = datetime.now() + timedelta(minutes=ttl)

    def set_signal_expiration(self, signal_id: str, ttl_min: Optional[int] = None):
        ttl = ttl_min if ttl_min is not None else self.signal_ttl_min
        self._signal_expirations[signal_id] = datetime.now() + timedelta(minutes=ttl)

    def pre_is_expired(self, pre_id: str) -> bool:
        exp = self._pre_expirations.get(pre_id)
        return exp is not None and datetime.now() >= exp

    def signal_is_expired(self, signal_id: str) -> bool:
        exp = self._signal_expirations.get(signal_id)
        return exp is not None and datetime.now() >= exp
    
    def configurar_bot_telegram(self, bot):
        """Configura el bot de Telegram"""
        self.bot_telegram = bot
        print("[SignalScheduler] Bot de Telegram configurado")
    
    def esta_en_horario_operativo(self) -> bool:
        """Verifica si estamos en horario operativo (8:00-20:00, Lun-S√°b)"""
        # Delegar a es_horario_operativo() que tiene la l√≥gica completa
        return self.es_horario_operativo()

    def enable_override_until(self, hasta: datetime):
        """Habilita un override temporal de horario hasta la fecha/hora indicada"""
        self._override_until = hasta
        print(f"[SignalScheduler] ‚è© Override de horario habilitado hasta: {hasta.strftime('%Y-%m-%d %H:%M:%S')}")

    def enable_override_until_midnight_today(self):
        """Habilita override hasta las 23:59:59 de hoy"""
        ahora = datetime.now()
        hasta = ahora.replace(hour=23, minute=59, second=59, microsecond=0)
        self.enable_override_until(hasta)
    
    def calcular_intervalo_se√±ales(self) -> int:
        """
        Calcula el intervalo entre se√±ales para alcanzar el objetivo diario
        Horario: 8:00-20:00 = 12 horas = 720 minutos
        Objetivo: 25 se√±ales = 720/25 = ~29 minutos entre se√±ales
        """
        minutos_operativos = 12 * 60  # 720 minutos
        intervalo = minutos_operativos // self.objetivo_se√±ales_diarias
        return max(20, min(60, intervalo))  # Entre 20-60 minutos
    
    async def iniciar_dia_trading(self):
        """Inicia el d√≠a de trading con mensaje motivacional"""
        if not self.esta_en_horario_operativo():
            return
        # Pausa por conexi√≥n
        if self.pausado_por_conexion:
            print("[SignalScheduler] ‚è∏Ô∏è Inicio de d√≠a pausado: sin conexi√≥n a Quotex")
            return
        
        # Seleccionar mejor mercado del d√≠a
        self.mercado_actual = await self.market_manager.seleccionar_mejor_mercado()
        if not self.mercado_actual:
            print("[SignalScheduler] ‚ùå No se pudo seleccionar mercado")
            return
        
        # Generar mensaje de inicio
        efectividad_esperada = self.mercado_actual.get('efectividad_calculada', 75)
        categoria_dia = self.categorizar_expectativa_dia(efectividad_esperada)
        frase_inicio = random.choice(self.frases_motivacionales[categoria_dia])
        
        mensaje_inicio = f"""
üåÖ **INICIO DEL D√çA DE TRADING**

{frase_inicio}

üìä **INFORMACI√ìN DEL D√çA:**
‚Ä¢ üí± **Mercado seleccionado:** {self.mercado_actual['symbol']}
‚Ä¢ üí∞ **Payout:** {self.mercado_actual['payout']}%
‚Ä¢ üìà **Efectividad esperada:** {efectividad_esperada:.1f}%
‚Ä¢ üéØ **Objetivo de se√±ales:** {self.objetivo_se√±ales_diarias}
‚Ä¢ ‚è∞ **Horario operativo:** 8:00 AM - 8:00 PM

üîë **Clave del d√≠a:** `{self.user_manager.clave_publica_diaria}`

¬°Prep√°rense para un d√≠a exitoso! üí™üöÄ
        """
        
        await self.enviar_mensaje_a_usuarios(mensaje_inicio.strip())
        print(f"[SignalScheduler] üåÖ D√≠a iniciado - Mercado: {self.mercado_actual['symbol']}")
    
    def categorizar_expectativa_dia(self, efectividad: float) -> str:
        """Categoriza el d√≠a seg√∫n la efectividad esperada"""
        if efectividad >= 85:
            return 'inicio_dia_excelente'
        elif efectividad >= 75:
            return 'inicio_dia_bueno'
        else:
            return 'inicio_dia_regular'
    
    async def programar_se√±ales_del_dia(self):
        """Programa las se√±ales del d√≠a"""
        if not self.mercado_actual:
            return
        if self.pausado_por_conexion:
            print("[SignalScheduler] ‚è∏Ô∏è Programaci√≥n de se√±ales pausada por p√©rdida de conexi√≥n")
            return
        
        intervalo_minutos = self.calcular_intervalo_se√±ales()
        hora_inicio = datetime.now().replace(hour=8, minute=0, second=0, microsecond=0)
        hora_fin = datetime.now().replace(hour=20, minute=0, second=0, microsecond=0)
        
        # Si ya pas√≥ la hora de inicio, comenzar desde ahora
        if datetime.now() > hora_inicio:
            hora_inicio = datetime.now() + timedelta(minutes=5)
        
        se√±ales_programadas = []
        hora_actual = hora_inicio
        
        while hora_actual < hora_fin and len(se√±ales_programadas) < self.objetivo_se√±ales_diarias:
            # Agregar variaci√≥n aleatoria al intervalo (¬±5 minutos)
            variacion = random.randint(-5, 5)
            hora_se√±al = hora_actual + timedelta(minutes=variacion)
            
            if hora_se√±al < hora_fin:
                se√±ales_programadas.append(hora_se√±al)
            
            hora_actual += timedelta(minutes=intervalo_minutos)
        
        self.se√±ales_programadas = se√±ales_programadas
        print(f"[SignalScheduler] üìÖ {len(se√±ales_programadas)} se√±ales programadas")
    
    async def ejecutar_analisis_se√±al(self) -> Optional[Dict]:
        """Ejecuta el an√°lisis completo para generar una se√±al"""
        try:
            if not self.mercado_actual:
                return None
            
            # Obtener datos del mercado
            df = await self.market_manager.obtener_datos_mercado(self.mercado_actual['symbol'])
            if df is None or len(df) < 50:
                return None
            
            # Ejecutar an√°lisis completo
            from src.strategies.evaluar_estrategia_completa import evaluar_estrategia_completa
            resultado = evaluar_estrategia_completa(df, self.mercado_actual['symbol'])
            
            # Verificar si la se√±al es v√°lida (efectividad ‚â• 80%)
            efectividad = resultado.get('efectividad_total', 0)
            decision = resultado.get('decision')
            
            if decision and efectividad >= 80:
                # Obtener precio actual de entrada
                precio_entrada = df['close'].iloc[-1] if df is not None and len(df) > 0 else None
                
                # Crear datos de la se√±al
                se√±al = {
                    'numero': len(self.se√±ales_enviadas_hoy) + 1,
                    'hora': datetime.now().strftime('%H:%M'),
                    'timestamp': datetime.now().isoformat(),
                    'symbol': self.mercado_actual['symbol'],
                    'direccion': decision,
                    'efectividad': efectividad,
                    'payout': self.mercado_actual['payout'],
                    'validez_minutos': 5,
                    'precio_entrada': float(precio_entrada) if precio_entrada else None,
                    'detalles_tecnicos': resultado.get('resumen', {}),
                    'pullback_info': resultado.get('pullback_detectado', False),
                    'tendencia': resultado.get('tendencia_direccion', 'N/A'),
                    'volatilidad': resultado.get('volatilidad_estado', 'N/A'),
                    'resultado': None  # Se actualizar√° autom√°ticamente despu√©s de 5 minutos
                }
                
                return se√±al
            else:
                print(f"[SignalScheduler] ‚ö†Ô∏è Se√±al no v√°lida - Efectividad: {efectividad}%")
                return None
                
        except Exception as e:
            print(f"[SignalScheduler] ‚ùå Error en an√°lisis: {e}")
            return None
    
    async def enviar_pre_se√±al(self, minutos_antes: int = 3):
        """Env√≠a notificaci√≥n previa a la se√±al"""
        # Guard: requerir conexi√≥n real a Quotex
        try:
            mm = getattr(self, 'market_manager', None)
            conectado_qx = bool(getattr(mm, 'conectado', False)) or (getattr(mm, 'quotex', None) is not None)
            if not conectado_qx:
                print("[SignalScheduler] üö´ Pre‚ÄëSe√±al abortada: sin conexi√≥n a Quotex.")
                # Notificar admin si es posible
                try:
                    if getattr(self, 'bot_telegram', None) and hasattr(self.bot_telegram, 'notificar_admin_telegram'):
                        await self.bot_telegram.notificar_admin_telegram("‚ö†Ô∏è Pre‚ÄëSe√±al abortada: sin conexi√≥n a Quotex.")
                except Exception:
                    pass
                return
        except Exception:
            pass
        frase_pre = random.choice(self.frases_motivacionales['pre_se√±al'])
        # Generar un ID √∫nico de pre-se√±al
        self.pre_id_actual = datetime.now().strftime('%Y%m%d%H%M%S')
        # Programar caducidad de pre‚Äëse√±al
        try:
            self.set_pre_expiration(self.pre_id_actual)
        except Exception:
            pass
        try:
            # Si existen helpers de espera, lanzarlos
            if hasattr(self, '_esperar_caducidad_presenal'):
                import asyncio as _aio
                try:
                    _aio.create_task(self._esperar_caducidad_presenal(self.pre_id_actual))
                except RuntimeError:
                    # Si no hay loop activo, delegar al loop del bot si existe
                    if getattr(self, 'bot_telegram', None) and getattr(self.bot_telegram, 'application', None):
                        loop = self.bot_telegram.application.bot.loop
                        loop.create_task(self._esperar_caducidad_presenal(self.pre_id_actual))
        except Exception:
            pass
        # Delegar al bot de Telegram para mostrar el bot√≥n de confirmaci√≥n
        if self.bot_telegram is not None and hasattr(self.bot_telegram, 'enviar_confirmacion_presenal_a_usuarios'):
            try:
                await self.bot_telegram.enviar_confirmacion_presenal_a_usuarios(
                    pre_id=self.pre_id_actual,
                    minutos_antes=minutos_antes,
                    mercado=self.mercado_actual['symbol'],
                    frase=frase_pre
                )
            except Exception as e:
                print(f"[SignalScheduler] ‚ùå Error enviando confirmaci√≥n Pre-Se√±al: {e}")
        else:
            print("[SignalScheduler] ‚ö†Ô∏è Bot de Telegram no configurado para confirmaci√≥n de Pre-Se√±al")

    async def enviar_se√±al(self, se√±al: Dict):
        """Env√≠a la se√±al formateada a los usuarios"""
        # Guard: requerir conexi√≥n real a Quotex
        try:
            mm = getattr(self, 'market_manager', None)
            conectado_qx = bool(getattr(mm, 'conectado', False)) or (getattr(mm, 'quotex', None) is not None)
            if not conectado_qx:
                print("[SignalScheduler] üö´ Se√±al abortada: sin conexi√≥n a Quotex.")
                try:
                    if getattr(self, 'bot_telegram', None) and hasattr(self.bot_telegram, 'notificar_admin_telegram'):
                        await self.bot_telegram.notificar_admin_telegram("‚ö†Ô∏è Se√±al abortada: sin conexi√≥n a Quotex.")
                except Exception:
                    pass
                return
        except Exception:
            pass
        # Guardar se√±al como pendiente y generar ID
        self.signal_id_actual = datetime.now().strftime('%Y%m%d%H%M%S')
        # Generar y adjuntar mensaje formateado completo para que el callback lo muestre
        try:
            mensaje_fmt = self.generar_mensaje_se√±al_completo(
                se√±al,
                se√±al.get('detalles_tecnicos', {}) if isinstance(se√±al, dict) else {}
            )
            if isinstance(se√±al, dict):
                se√±al['mensaje_formateado'] = mensaje_fmt
        except Exception:
            # En caso de error al formatear, continuar sin bloquear el env√≠o
            pass
        self.senales_pendientes[self.signal_id_actual] = se√±al
        # Programar caducidad de se√±al
        try:
            self.set_signal_expiration(self.signal_id_actual)
        except Exception:
            pass
        try:
            if hasattr(self, '_esperar_caducidad_senal'):
                import asyncio as _aio
                try:
                    _aio.create_task(self._esperar_caducidad_senal(self.pre_id_actual, self.signal_id_actual))
                except RuntimeError:
                    if getattr(self, 'bot_telegram', None) and getattr(self.bot_telegram, 'application', None):
                        loop = self.bot_telegram.application.bot.loop
                        loop.create_task(self._esperar_caducidad_senal(self.pre_id_actual, self.signal_id_actual))
        except Exception:
            pass
        # Mostrar confirmaci√≥n de Se√±al a usuarios (solo quienes confirmaron Pre-Se√±al deben poder aceptarla)
        if self.bot_telegram is not None and hasattr(self.bot_telegram, 'enviar_confirmacion_senal_a_usuarios'):
            try:
                await self.bot_telegram.enviar_confirmacion_senal_a_usuarios(
                    signal_id=self.signal_id_actual,
                    pre_id=self.pre_id_actual,
                    se√±al=se√±al
                )
            except Exception as e:
                print(f"[SignalScheduler] ‚ùå Error enviando confirmaci√≥n Se√±al: {e}")
        else:
            print("[SignalScheduler] ‚ö†Ô∏è Bot de Telegram no configurado para confirmaci√≥n de Se√±al")
        # Registrar se√±al en historial del d√≠a (registro administrativo)
        self.se√±ales_enviadas_hoy.append(se√±al)
        self.user_manager.registrar_se√±al_enviada(se√±al)
        print(f"[SignalScheduler] üì§ Se√±al #{se√±al['numero']} preparada y confirmaci√≥n enviada")
        
        # TRADING AUTOM√ÅTICO: Ejecutar operaci√≥n si est√° activo
        try:
            if self.bot_telegram and hasattr(self.bot_telegram, '_trading_activo'):
                if getattr(self.bot_telegram, '_trading_activo', False):
                    await self.ejecutar_operacion_automatica(se√±al)
        except Exception as e:
            print(f"[Trading] ‚ùå Error ejecutando operaci√≥n autom√°tica: {e}")
        
        # Programar verificaci√≥n autom√°tica del resultado despu√©s de 5 minutos
        try:
            import asyncio as _aio
            _aio.create_task(self.verificar_resultado_se√±al_automatico(se√±al))
            print(f"[SignalScheduler] ‚è∞ Verificaci√≥n de resultado programada para 5 minutos")
        except Exception as e:
            print(f"[SignalScheduler] ‚ö†Ô∏è Error programando verificaci√≥n de resultado: {e}")

    # ================== Monitor de conexi√≥n y control de pausa ==================
    def _esta_conectado_qx(self) -> bool:
        try:
            mm = getattr(self, 'market_manager', None)
            return bool(getattr(mm, 'conectado', False)) or (getattr(mm, 'quotex', None) is not None)
        except Exception:
            return False

    async def monitor_conexion_quotex(self):
        """Supervisa el estado de conexi√≥n a Quotex y pausa/reanuda autom√°ticamente el scheduler."""
        base_sleep = 10
        max_sleep = 120
        sleep_ok = 30
        cur_sleep = base_sleep
        while True:
            try:
                conectado = self._esta_conectado_qx()
                if not conectado:
                    if not self.pausado_por_conexion:
                        self.pausado_por_conexion = True
                        print("[SignalScheduler] üî¥ Conexi√≥n a Quotex perdida. Scheduler en pausa.")
                        try:
                            if getattr(self, 'bot_telegram', None) and hasattr(self.bot_telegram, 'notificar_admin_telegram'):
                                await self.bot_telegram.notificar_admin_telegram("üî¥ Conexi√≥n a Quotex perdida. El scheduler fue pausado.")
                        except Exception:
                            pass
                    # Backoff exponencial mientras est√© desconectado
                    import asyncio as _aio
                    await _aio.sleep(cur_sleep)
                    cur_sleep = min(max_sleep, cur_sleep * 2)
                    continue
                # Conectado
                if self.pausado_por_conexion:
                    self.pausado_por_conexion = False
                    print("[SignalScheduler] üü¢ Conexi√≥n a Quotex restablecida. Reanudando scheduler.")
                    try:
                        if getattr(self, 'bot_telegram', None) and hasattr(self.bot_telegram, 'notificar_admin_telegram'):
                            await self.bot_telegram.notificar_admin_telegram("üü¢ Conexi√≥n a Quotex restablecida. Scheduler reanudado.")
                    except Exception:
                        pass
                    # Replanificar si estamos en horario operativo
                    try:
                        if self.esta_en_horario_operativo():
                            # Seleccionar mercado y reprogramar se√±ales del d√≠a
                            self.mercado_actual = await self.market_manager.seleccionar_mejor_mercado()
                            if self.mercado_actual:
                                await self.programar_se√±ales_del_dia()
                                # Notificaci√≥n opcional a usuarios: servicio restablecido
                                try:
                                    await self.enviar_pre_notificacion_se√±al(motivo="servicio restablecido", minutos_antes=3)
                                except Exception:
                                    pass
                    except Exception as e:
                        print(f"[SignalScheduler] ‚ö†Ô∏è Error reprogramando tras reconexi√≥n: {e}")
                    # Reset backoff al volver
                    cur_sleep = base_sleep
                # Dormir en estado OK
                import asyncio as _aio
                await _aio.sleep(sleep_ok)
            except Exception:
                # En caso de error en el loop, esperar un poco y continuar
                import asyncio as _aio
                await _aio.sleep(10)

    def obtener_senal_por_id(self, signal_id: str) -> Optional[Dict]:
        """Devuelve la se√±al pendiente por su ID."""
        return self.senales_pendientes.get(str(signal_id))

    # ================== Programaci√≥n de caducidades ==================
    async def _esperar_caducidad_presenal(self, pre_id: str):
        """Espera hasta la caducidad de la pre‚Äëse√±al y notifica a usuarios pendientes."""
        try:
            exp = self._pre_expirations.get(pre_id)
            if not exp:
                return
            segundos = max(0, (exp - datetime.now()).total_seconds())
            import asyncio as _aio
            await _aio.sleep(segundos)
        except Exception:
            pass
        # Si ya caduc√≥, notificar a trav√©s del bot si est√° disponible
        try:
            if self.pre_is_expired(pre_id) and getattr(self, 'bot_telegram', None):
                if hasattr(self.bot_telegram, 'notificar_caducidad_presenal'):
                    await self.bot_telegram.notificar_caducidad_presenal(pre_id)
        except Exception:
            pass

    async def _esperar_caducidad_senal(self, pre_id: str, signal_id: str):
        """Espera hasta la caducidad de la se√±al y notifica a usuarios pendientes."""
        try:
            exp = self._signal_expirations.get(signal_id)
            if not exp:
                return
            segundos = max(0, (exp - datetime.now()).total_seconds())
            import asyncio as _aio
            await _aio.sleep(segundos)
        except Exception:
            pass
        try:
            if self.signal_is_expired(signal_id) and getattr(self, 'bot_telegram', None):
                if hasattr(self.bot_telegram, 'notificar_caducidad_senal'):
                    await self.bot_telegram.notificar_caducidad_senal(pre_id, signal_id)
        except Exception:
            pass
    
    def generar_mensaje_se√±al_completo(self, se√±al: Dict, detalles: Dict) -> str:
        """Genera mensaje de se√±al con formato completo seg√∫n especificaci√≥n del usuario"""
        # Formatear hora a AM/PM
        try:
            from datetime import datetime
            hora_obj = datetime.strptime(se√±al['hora'], '%H:%M')
            hora_formateada = hora_obj.strftime('%I:%M %p')
        except:
            hora_formateada = se√±al['hora']
        
        # Formatear direcci√≥n
        direccion = se√±al['direccion'].upper()
        direccion_texto = "CALL (Compra)" if direccion == "CALL" else "PUT (Venta)"
        
        # An√°lisis de pullback
        pullback_info = se√±al.get('pullback_info', {})
        pullback_esperado = "‚úÖ S√≠" if pullback_info.get('detectado', False) else "‚ùå No"
        pullback_probabilidad = pullback_info.get('probabilidad_efectividad', 0)
        pullback_motivo = pullback_info.get('motivo', "An√°lisis t√©cnico est√°ndar sin pullback espec√≠fico detectado.")
        
        # Detalles t√©cnicos
        tendencia_info = detalles.get('tendencia', {})
        soporte_resistencia = detalles.get('soportes_resistencias', {})
        patrones = detalles.get('patrones', {})
        volatilidad_info = detalles.get('volatilidad', {})
        
        # Obtener mejor patr√≥n
        patrones_detalles = patrones.get('detalles', {}) if isinstance(patrones, dict) else {}
        mejor_patron = patrones_detalles.get('mejor_patron', {})
        patron_nombre = mejor_patron.get('nombre', 'Patr√≥n est√°ndar').capitalize()
        
        # Informaci√≥n de tendencia
        tendencia_direccion = tendencia_info.get('direccion_final', 'Neutral')
        tendencia_texto = "Alcista s√≥lida (m√≠nimos y m√°ximos ascendentes)" if tendencia_direccion == 'ALCISTA' else "Bajista s√≥lida (m√°ximos y m√≠nimos descendentes)" if tendencia_direccion == 'BAJISTA' else "Lateral con consolidaci√≥n"
        
        # Zona clave (simulada basada en soporte/resistencia)
        zona_clave = soporte_resistencia.get('nivel_clave', se√±al.get('precio_actual', '1.09240'))
        zona_tipo = "Soporte" if direccion == "CALL" else "Resistencia"
        
        # Volatilidad
        volatilidad_texto = volatilidad_info.get('nivel', 'Media')
        ultima_vela_pips = volatilidad_info.get('ultima_vela_pips', 45)
        promedio_pips = volatilidad_info.get('promedio_pips', 35)
        
        # Verificar si es s√°bado para a√±adir notificaci√≥n OTC
        es_sabado = datetime.now().weekday() == 5
        notificacion_sabado = ""
        if es_sabado:
            notificacion_sabado = "\n\nüìÖ **S√ÅBADO - SOLO MERCADOS OTC**\n‚ö†Ô∏è Los mercados normales est√°n cerrados. Operamos √∫nicamente mercados OTC que funcionan 24/7 sin horarios de noticias."
        
        # Recomendaci√≥n del bot
        recomendacion = f"Ejecutar entrada {direccion} inmediatamente si la vela actual cierra {'alcista' if direccion == 'CALL' else 'bajista'} con cuerpo completo."
        if pullback_info.get('detectado', False):
            recomendacion += f" Esperar retroceso leve (pullback) antes de entrar puede mejorar el punto de entrada, pero no es obligatorio dada la fuerza actual del mercado."
        
        mensaje = f"""üìä Se√±al #{se√±al['numero']:02d}  
üïí Hora: {hora_formateada}
üìà Activo: {se√±al['symbol']}  
üìç Direcci√≥n: {direccion_texto}  
‚è≥ V√°lido por: {se√±al.get('validez_minutos', 5)} minutos  
üéØ Efectividad estimada: {se√±al['efectividad']:.0f}%{notificacion_sabado}

üîÅ Pullback esperado: {pullback_esperado}  
üìä Probabilidad de efectividad del pullback: {pullback_probabilidad:.0f}%  
üìå Motivo: {pullback_motivo}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  
üìå Detalles t√©cnicos:

- üìâ Tendencia principal: {tendencia_texto}  
- üìç Zona clave: {zona_tipo} reciente en {zona_clave} (antigua {'resistencia rota' if direccion == 'CALL' else 'soporte roto'})  
- üìä Patr√≥n detectado: {patron_nombre} en zona + confirmaci√≥n con vela fuerte {'verde' if direccion == 'CALL' else 'roja'}  
- üî• Volatilidad: {volatilidad_texto} ‚Üí √öltima vela: +{ultima_vela_pips} pips | Promedio: {promedio_pips} pips  
- üéØ Acci√≥n del precio: Rechazo limpio de la zona + presi√≥n {'compradora' if direccion == 'CALL' else 'vendedora'} creciente

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  
‚ö†Ô∏è Recomendaci√≥n del bot:  
{recomendacion}

ü§ñ ‚Äì Se√±al generada por el Bot CubaYDsignal"""
        
        return mensaje
    
    async def enviar_pre_notificacion_se√±al(self, mercado: str = None, motivo: str = None, minutos_antes: int = 3):
        """Env√≠a pre-notificaci√≥n antes de una se√±al con mercado y motivo"""
        # Obtener mercado actual si no se proporciona
        if not mercado and self.mercado_actual:
            mercado = self.mercado_actual.get('symbol', 'EUR/USD')
        elif not mercado:
            mercado = 'EUR/USD'
        
        # Generar motivo si no se proporciona
        if not motivo:
            motivos_posibles = [
                "confluencia t√©cnica detectada en zona clave",
                "patr√≥n de reversi√≥n confirmado con alta efectividad",
                "ruptura de zona importante con volumen",
                "pullback saludable en tendencia principal",
                "formaci√≥n de patr√≥n alcista/bajista en soporte/resistencia",
                "se√±ales m√∫ltiples convergiendo en la misma direcci√≥n"
            ]
            motivo = random.choice(motivos_posibles)
        
        mensaje_pre = f"""üîî **ALERTA DE SE√ëAL**

üö® ¬°Atenci√≥n traders!
En aproximadamente **{minutos_antes} minutos** se generar√° una nueva se√±al.

üí± **Mercado:** {mercado}
üîç **Motivo:** {motivo}

üëÄ Mantente atento a tu dispositivo
üì± Prep√°rate para recibir la se√±al
üéØ ¬°La oportunidad se acerca!

ü§ñ ‚Äì Bot CubaYDsignal"""
        
        await self.enviar_mensaje_a_usuarios(mensaje_pre)
        print(f"[SignalScheduler] üîî Pre-notificaci√≥n enviada ({minutos_antes} min antes) - {mercado}")
    
    async def generar_informe_diario_completo(self):
        """Genera informe diario completo con estad√≠sticas y an√°lisis"""
        if not self.se√±ales_enviadas_hoy:
            return "No se enviaron se√±ales hoy."
        
        # Calcular estad√≠sticas generales
        total_se√±ales = len(self.se√±ales_enviadas_hoy)
        se√±ales_ganadas = sum(1 for s in self.se√±ales_enviadas_hoy if s.get('resultado') == 'WIN')
        se√±ales_perdidas = total_se√±ales - se√±ales_ganadas
        se√±ales_pendientes = sum(1 for s in self.se√±ales_enviadas_hoy if s.get('resultado') not in {'WIN', 'LOSS'})
        efectividad_total = (se√±ales_ganadas / total_se√±ales * 100) if total_se√±ales > 0 else 0
        
        # Obtener activos operados
        activos_operados = list(set(s['symbol'] for s in self.se√±ales_enviadas_hoy))
        activos_texto = ", ".join(activos_operados)
        
        # Payout por activo
        payout_por_activo = {}
        for activo in activos_operados:
            pagos = [float(s.get('payout', 0)) for s in self.se√±ales_enviadas_hoy if s['symbol'] == activo and s.get('payout') is not None]
            payout_prom = sum(pagos) / len(pagos) if pagos else 0
            payout_por_activo[activo] = payout_prom

        # Fecha actual
        fecha_hoy = datetime.now().strftime('%d de %B de %Y')
        
        # Generar resumen de se√±ales
        resumen_se√±ales = []
        for i, se√±al in enumerate(self.se√±ales_enviadas_hoy, 1):
            # Formatear hora
            try:
                hora_obj = datetime.strptime(se√±al['hora'], '%H:%M')
                hora_formateada = hora_obj.strftime('%I:%M %p')
            except:
                hora_formateada = se√±al['hora']
            
            resultado_emoji = "‚úÖ Ganada" if se√±al.get('resultado') == 'WIN' else "‚ùå Perdida"
            pullback_info = se√±al.get('pullback_info', {})
            pullback_texto = "‚úÖ S√≠" if pullback_info.get('detectado', False) else "‚ùå No"
            
            linea = f"{i}. Se√±al #{i:03d} - {hora_formateada} - {se√±al['symbol']} - {se√±al['direccion']} - {resultado_emoji} - Pullback: {pullback_texto}"
            resumen_se√±ales.append(linea)
        
        # An√°lisis por activo
        analisis_activos = []
        for activo in activos_operados:
            se√±ales_activo = [s for s in self.se√±ales_enviadas_hoy if s['symbol'] == activo]
            total_activo = len(se√±ales_activo)
            ganadas_activo = sum(1 for s in se√±ales_activo if s.get('resultado') == 'WIN')
            efectividad_activo = (ganadas_activo / total_activo * 100) if total_activo > 0 else 0
            
            estado_emoji = "‚úÖ" if efectividad_activo >= 70 else "‚ö†Ô∏è" if efectividad_activo >= 50 else "‚ùå"
            payout_prom = payout_por_activo.get(activo, 0)
            linea_activo = (
                f"- {activo}: {total_activo} se√±ales ‚Üí {ganadas_activo} ganadas ‚Üí "
                f"Efectividad: {efectividad_activo:.1f}% {estado_emoji} ‚Üí Payout prom.: {payout_prom:.0f}%"
            )
            analisis_activos.append(linea_activo)
        
        # An√°lisis de pullbacks
        se√±ales_con_pullback = [s for s in self.se√±ales_enviadas_hoy if s.get('pullback_info', {}).get('detectado', False)]
        total_pullbacks = len(se√±ales_con_pullback)
        ganadas_pullback = sum(1 for s in se√±ales_con_pullback if s.get('resultado') == 'WIN')
        efectividad_pullback = (ganadas_pullback / total_pullbacks * 100) if total_pullbacks > 0 else 0
        se√±ales_sin_pullback = [s for s in self.se√±ales_enviadas_hoy if not s.get('pullback_info', {}).get('detectado', False)]
        total_sin_pullback = len(se√±ales_sin_pullback)
        ganadas_sin_pullback = sum(1 for s in se√±ales_sin_pullback if s.get('resultado') == 'WIN')
        efectividad_sin_pullback = (ganadas_sin_pullback / total_sin_pullback * 100) if total_sin_pullback > 0 else 0
        comparativa_pullback = ""
        if total_pullbacks > 0 and total_sin_pullback > 0:
            dif = efectividad_pullback - efectividad_sin_pullback
            if abs(dif) >= 1:
                tendencia = "super√≥" if dif > 0 else "estuvo por debajo"
                comparativa_pullback = f"(Pullback {tendencia} por {abs(dif):.1f} pts a las se√±ales directas)"

        # Observaciones inteligentes
        mejor_activo = max(
            activos_operados,
            key=lambda a: (
                (sum(1 for s in self.se√±ales_enviadas_hoy if s['symbol'] == a and s.get('resultado') == 'WIN') /
                 max(1, sum(1 for s in self.se√±ales_enviadas_hoy if s['symbol'] == a))) * 100
            ),
            default="N/A"
        )

        # Mini-resumen por activo: √∫ltimas 3 se√±ales (ordenadas por timestamp si existe)
        mini_resumen_activos = []
        for activo in activos_operados:
            sa = [s for s in self.se√±ales_enviadas_hoy if s['symbol'] == activo]
            try:
                sa.sort(key=lambda s: s.get('timestamp', ''), reverse=True)
            except Exception:
                pass
            ultimas = sa[:3]
            lineas = []
            for s in ultimas:
                # hora amigable
                try:
                    hobj = datetime.strptime(s['hora'], '%H:%M')
                    hfmt = hobj.strftime('%I:%M %p')
                except Exception:
                    hfmt = s.get('hora', '?')
                res = s.get('resultado')
                res_txt = 'WIN' if res == 'WIN' else 'LOSS' if res == 'LOSS' else 'PEND'
                lineas.append(f"‚Ä¢ {hfmt} {s.get('direccion','?')} {res_txt}")
            newline = "\n"
            mini = f"{activo}:{newline}" + (newline.join(lineas) if lineas else "(sin datos)")
            mini_resumen_activos.append(mini)

        # Top patrones del d√≠a (frecuencia y efectividad)
        patrones_stats = {}
        for s in self.se√±ales_enviadas_hoy:
            det = s.get('detalles_tecnicos', {})
            pat = det.get('patrones', {})
            mejor = pat.get('detalles', {}).get('mejor_patron', {})
            nombre = (mejor.get('nombre') or 'desconocido').lower()
            if nombre not in patrones_stats:
                patrones_stats[nombre] = {'total': 0, 'win': 0}
            patrones_stats[nombre]['total'] += 1
            if s.get('resultado') == 'WIN':
                patrones_stats[nombre]['win'] += 1
        # Ordenar por frecuencia
        top_patrones = sorted(patrones_stats.items(), key=lambda kv: kv[1]['total'], reverse=True)
        top_lineas = []
        for nombre, st in top_patrones[:5]:
            efect = (st['win'] / st['total']) * 100 if st['total'] else 0
            top_lineas.append(f"- {nombre.capitalize()}: {st['total']} se√±ales ‚Üí {efect:.1f}% WIN")

        # Estado de Quotex si disponemos de m√©tricas en MarketManager
        estado_qx = []
        try:
            mm = getattr(self, 'market_manager', None)
            if mm is not None:
                reconex = getattr(mm, 'reconexiones', None)
                tdesc = getattr(mm, 'tiempo_desconectado_min', None)
                mercado_mas_rent = None
                # mercado m√°s rentable (por efectividad)
                mercados_eff = {}
                for act in activos_operados:
                    sa = [s for s in self.se√±ales_enviadas_hoy if s['symbol'] == act]
                    if not sa:
                        continue
                    wins = sum(1 for s in sa if s.get('resultado') == 'WIN')
                    mercados_eff[act] = (wins / len(sa)) * 100
                if mercados_eff:
                    mercado_mas_rent = max(mercados_eff, key=mercados_eff.get)
                if reconex is not None:
                    estado_qx.append(f"- Reconexiones: {reconex}")
                if tdesc is not None:
                    estado_qx.append(f"- Tiempo desconectado: {tdesc} min")
                if mercado_mas_rent:
                    estado_qx.append(f"- Mercado m√°s rentable: {mercado_mas_rent} ({mercados_eff[mercado_mas_rent]:.1f}% WIN)")
        except Exception:
            pass
        
        # Generar informe completo
        newline = "\n"
        separador = "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        estado_quotex_section = ""
        if estado_qx:
            estado_quotex_section = f"{newline}{separador}{newline}üîå Estado Quotex:{newline}{newline.join(estado_qx)}"
        
        fire_emoji = 'üî•' if efectividad_pullback >= 80 else '‚úÖ' if efectividad_pullback >= 60 else '‚ö†Ô∏è'
        
        informe = f"""**Informe Diario de Se√±ales (CubaYDSignal)**

üìÖ Fecha: {fecha_hoy}
üïí Horario de se√±ales: 08:00 AM ‚Äì 08:00 PM
üìà Activos operados: {activos_texto}

üì° Total de se√±ales enviadas: {total_se√±ales}
‚úÖ Se√±ales ganadas: {se√±ales_ganadas}
‚ùå Se√±ales perdidas: {se√±ales_perdidas}
‚è≥ Se√±ales pendientes: {se√±ales_pendientes}
üéØ Efectividad total del d√≠a: {efectividad_total:.1f}%

{separador}
üìå Resumen de se√±ales:
{newline.join(resumen_se√±ales)}

{separador}
üìà An√°lisis del rendimiento:
{newline.join(analisis_activos)}

üîÅ Pullbacks:
- Total de se√±ales con pullback: {total_pullbacks}
- Ganadas con pullback: {ganadas_pullback} ‚Üí Efectividad pullback: {efectividad_pullback:.1f}% {fire_emoji}
- Total sin pullback: {total_sin_pullback}
- Ganadas sin pullback: {ganadas_sin_pullback} ‚Üí Efectividad sin pullback: {efectividad_sin_pullback:.1f}% {comparativa_pullback}

{separador}
üß© Top patrones del d√≠a:
{newline.join(top_lineas) if top_lineas else '- Sin datos de patrones'}

{separador}
üóÇÔ∏è √öltimas 3 por activo:
{newline.join(mini_resumen_activos)}

{estado_quotex_section}

üìå Observaciones:
‚úîÔ∏è {mejor_activo} sigue siendo el activo m√°s confiable hoy
‚ö° El {efectividad_pullback:.0f}% de se√±ales con pullback fueron efectivas
‚úÖ Las mejores se√±ales fueron combinaciones de:
   - Zona fuerte (soporte/resistencia)
   - Patr√≥n confirmado (Martillo / Envolvente)
   - Acci√≥n del precio clara (rechazo con volumen)

üìç Recomendaci√≥n para ma√±ana:
‚Üí Priorizar entradas con pullback confirmado y patr√≥n fuerte
‚Üí Operar m√°s en {mejor_activo} en sesiones europeas y apertura americana

üìâ Pr√≥ximo escaneo del bot: 08:00 AM"""
        
        return informe
    
    async def generar_mensaje_motivacional_diario(self, efectividad: float) -> str:
        """Genera mensaje motivacional personalizado seg√∫n la efectividad del d√≠a"""
        # Seleccionar categor√≠a seg√∫n efectividad
        if efectividad >= 80:
            categoria = 'cierre_exitoso'
        elif efectividad >= 60:
            categoria = 'cierre_estable'
        else:
            categoria = 'cierre_dificil'
        
        # Seleccionar frase aleatoria de la categor√≠a
        frase_motivacional = random.choice(self.frases_motivacionales[categoria])
        
        # Construir mensaje completo
        mensaje = f"""Hoy lograste un {efectividad:.0f}% de efectividad.
{frase_motivacional}

Ma√±ana, las velas te esperan con nuevas oportunidades.
No se trata de adivinar, se trata de entender el lenguaje del mercado.

T√∫ no viniste a probar suerte‚Ä¶ viniste a dominar el juego.

üß† Mantente enfocado, la pr√≥xima jornada est√° a solo unas horas.

Nos vemos en la apertura‚Ä¶ üöÄ"""
        
        return mensaje
    
    async def enviar_bienvenida_diaria(self):
        """Env√≠a mensaje de bienvenida diario 15 minutos antes de las se√±ales"""
        from datetime import datetime
        
        # Seleccionar frase motivadora aleatoria
        frase_del_dia = random.choice(self.frases_motivacionales['bienvenida_diaria'])
        
        # Verificar si es s√°bado para a√±adir notificaci√≥n OTC
        es_sabado = datetime.now().weekday() == 5
        notificacion_sabado = ""
        if es_sabado:
            notificacion_sabado = "\n\nüìÖ **OPERACI√ìN DE S√ÅBADO**\nüéØ Hoy operaremos √∫nicamente mercados OTC (Over The Counter)\n‚ö†Ô∏è Los mercados normales est√°n cerrados hasta el lunes\nüîÑ Los OTC funcionan 24/7 sin horarios de noticias"
        
        mensaje_bienvenida = f"""üïó Buenos d√≠as, trader.

üéØ Hoy es un nuevo d√≠a de oportunidades en el mercado.
Prep√°rate para operar con enfoque, l√≥gica y disciplina.{notificacion_sabado}

üî• Frase del d√≠a:
"{frase_del_dia}"

üé≤ ¬°Que la suerte te acompa√±e hoy!
Pero recuerda: t√∫ no dependes de ella... t√∫ dependes de tu an√°lisis.
Nos vemos a las 8:00 AM con la primera se√±al del d√≠a.

ü§ñ CubaYDsignal"""
        
        await self.enviar_mensaje_a_usuarios(mensaje_bienvenida)
        print(f"[SignalScheduler] üåÖ Mensaje de bienvenida diario enviado")
    
    async def enviar_informe_y_motivacion_diaria(self):
        """Env√≠a informe diario completo y mensaje motivacional"""
        # Generar y enviar informe
        informe = await self.generar_informe_diario_completo()
        await self.enviar_mensaje_a_usuarios(informe)
        
        # Calcular efectividad para mensaje motivacional
        if self.se√±ales_enviadas_hoy:
            se√±ales_ganadas = sum(1 for s in self.se√±ales_enviadas_hoy if s.get('resultado') == 'WIN')
            efectividad = (se√±ales_ganadas / len(self.se√±ales_enviadas_hoy)) * 100
        else:
            efectividad = 0
        
        # Esperar un momento y enviar mensaje motivacional
        await asyncio.sleep(2)
        mensaje_motivacional = await self.generar_mensaje_motivacional_diario(efectividad)
        await self.enviar_mensaje_a_usuarios(mensaje_motivacional)
        
        print(f"[SignalScheduler] üìä Informe diario enviado - Efectividad: {efectividad:.1f}%")
    
    async def analizar_y_aprender_del_dia(self):
        """Analiza los resultados del d√≠a y ajusta estrategias para mejorar"""
        if not self.se√±ales_enviadas_hoy:
            return
        
        print("[SignalScheduler] üß† Iniciando an√°lisis de aprendizaje adaptativo...")
        
        # An√°lisis por mercado
        mercados_efectividad = {}
        for se√±al in self.se√±ales_enviadas_hoy:
            mercado = se√±al['symbol']
            resultado = se√±al.get('resultado', 'PENDING')
            
            if mercado not in mercados_efectividad:
                mercados_efectividad[mercado] = {'total': 0, 'ganadas': 0}
            
            mercados_efectividad[mercado]['total'] += 1
            if resultado == 'WIN':
                mercados_efectividad[mercado]['ganadas'] += 1
        
        # An√°lisis por patrones
        patrones_efectividad = {}
        for se√±al in self.se√±ales_enviadas_hoy:
            detalles = se√±al.get('detalles_tecnicos', {})
            patrones = detalles.get('patrones', {})
            mejor_patron = patrones.get('detalles', {}).get('mejor_patron', {})
            patron_nombre = mejor_patron.get('nombre', 'desconocido')
            resultado = se√±al.get('resultado', 'PENDING')
            
            if patron_nombre not in patrones_efectividad:
                patrones_efectividad[patron_nombre] = {'total': 0, 'ganadas': 0}
            
            patrones_efectividad[patron_nombre]['total'] += 1
            if resultado == 'WIN':
                patrones_efectividad[patron_nombre]['ganadas'] += 1
        
        # An√°lisis por pullback
        pullback_stats = {'con_pullback': {'total': 0, 'ganadas': 0}, 'sin_pullback': {'total': 0, 'ganadas': 0}}
        for se√±al in self.se√±ales_enviadas_hoy:
            pullback_info = se√±al.get('pullback_info', {})
            tiene_pullback = pullback_info.get('detectado', False)
            resultado = se√±al.get('resultado', 'PENDING')
            
            categoria = 'con_pullback' if tiene_pullback else 'sin_pullback'
            pullback_stats[categoria]['total'] += 1
            if resultado == 'WIN':
                pullback_stats[categoria]['ganadas'] += 1
        
        # Generar recomendaciones de aprendizaje
        recomendaciones = []
        
        # Recomendaciones por mercado
        for mercado, stats in mercados_efectividad.items():
            efectividad = (stats['ganadas'] / stats['total']) * 100 if stats['total'] > 0 else 0
            if efectividad < 50 and stats['total'] >= 3:
                recomendaciones.append(f"Reducir peso de {mercado} (efectividad: {efectividad:.1f}%)")
            elif efectividad > 80 and stats['total'] >= 2:
                recomendaciones.append(f"Priorizar {mercado} (efectividad: {efectividad:.1f}%)")
        
        # Recomendaciones por patrones
        for patron, stats in patrones_efectividad.items():
            if patron != 'desconocido' and stats['total'] >= 2:
                efectividad = (stats['ganadas'] / stats['total']) * 100
                if efectividad < 40:
                    recomendaciones.append(f"Reducir confianza en patr√≥n {patron} (efectividad: {efectividad:.1f}%)")
                elif efectividad > 85:
                    recomendaciones.append(f"Aumentar peso de patr√≥n {patron} (efectividad: {efectividad:.1f}%)")
        
        # Recomendaciones por pullback
        if pullback_stats['con_pullback']['total'] >= 2 and pullback_stats['sin_pullback']['total'] >= 2:
            efect_con = (pullback_stats['con_pullback']['ganadas'] / pullback_stats['con_pullback']['total']) * 100
            efect_sin = (pullback_stats['sin_pullback']['ganadas'] / pullback_stats['sin_pullback']['total']) * 100
            
            if efect_con > efect_sin + 20:
                recomendaciones.append(f"Priorizar se√±ales con pullback (efectividad: {efect_con:.1f}% vs {efect_sin:.1f}%)")
            elif efect_sin > efect_con + 20:
                recomendaciones.append(f"Priorizar se√±ales directas sin pullback (efectividad: {efect_sin:.1f}% vs {efect_con:.1f}%)")
        
        # Notificar al admin si hay recomendaciones
        if recomendaciones and self.telegram_bot:
            mensaje_aprendizaje = f"""üß† **APRENDIZAJE ADAPTATIVO - {datetime.now().strftime('%d/%m/%Y')}**

üìä El bot ha analizado los resultados del d√≠a y gener√≥ las siguientes recomendaciones:

"""
            
            for i, rec in enumerate(recomendaciones, 1):
                newline = "\n"
                mensaje_aprendizaje += f"{i}. {rec}{newline}"
            
            newline = "\n"
            mensaje_aprendizaje += f"{newline}üîÑ Estos ajustes se aplicar√°n autom√°ticamente en las pr√≥ximas se√±ales."
            
            await self.telegram_bot.notificar_admin_telegram(mensaje_aprendizaje)
            print(f"[SignalScheduler] üß† Aprendizaje adaptativo: {len(recomendaciones)} recomendaciones generadas")
        
        # Guardar aprendizajes para aplicar ma√±ana
        self.guardar_aprendizajes_del_dia({
            'mercados': mercados_efectividad,
            'patrones': patrones_efectividad,
            'pullback': pullback_stats,
            'recomendaciones': recomendaciones,
            'fecha': datetime.now().strftime('%Y-%m-%d')
        })
    
    def guardar_aprendizajes_del_dia(self, aprendizajes: Dict):
        """Guarda los aprendizajes del d√≠a para aplicar en futuras se√±ales"""
        try:
            import json
            archivo_aprendizaje = 'data/aprendizaje_adaptativo.json'
            
            # Crear directorio si no existe
            os.makedirs('data', exist_ok=True)
            
            # Cargar aprendizajes existentes
            aprendizajes_historicos = {}
            if os.path.exists(archivo_aprendizaje):
                with open(archivo_aprendizaje, 'r', encoding='utf-8') as f:
                    aprendizajes_historicos = json.load(f)
            
            # A√±adir nuevos aprendizajes
            fecha = aprendizajes['fecha']
            aprendizajes_historicos[fecha] = aprendizajes
            
            # Mantener solo los √∫ltimos 30 d√≠as
            fechas = sorted(aprendizajes_historicos.keys())
            if len(fechas) > 30:
                for fecha_vieja in fechas[:-30]:
                    del aprendizajes_historicos[fecha_vieja]
            
            # Guardar
            with open(archivo_aprendizaje, 'w', encoding='utf-8') as f:
                json.dump(aprendizajes_historicos, f, indent=2, ensure_ascii=False)
            
            print(f"[SignalScheduler] üíæ Aprendizajes guardados para {fecha}")
            
        except Exception as e:
            print(f"[SignalScheduler] ‚ùå Error guardando aprendizajes: {e}")
    
    async def verificar_resultado_se√±al_automatico(self, se√±al: Dict):
        """Verifica autom√°ticamente el resultado de una se√±al despu√©s de 5 minutos"""
        try:
            # Esperar 5 minutos (300 segundos)
            import asyncio as _aio
            await _aio.sleep(300)
            
            print(f"[SignalScheduler] üîç Verificando resultado de se√±al #{se√±al['numero']}...")
            
            # Obtener precio actual del mercado
            precio_actual = await self.obtener_precio_actual(se√±al['symbol'])
            
            if precio_actual is None:
                print(f"[SignalScheduler] ‚ö†Ô∏è No se pudo obtener precio actual para {se√±al['symbol']}")
                se√±al['resultado'] = 'PENDING'
                se√±al['motivo_pending'] = 'No se pudo verificar precio'
                return
            
            # Obtener precio de entrada (guardado en la se√±al)
            precio_entrada = se√±al.get('precio_entrada')
            
            if precio_entrada is None:
                print(f"[SignalScheduler] ‚ö†Ô∏è No hay precio de entrada registrado")
                se√±al['resultado'] = 'PENDING'
                se√±al['motivo_pending'] = 'Sin precio de entrada'
                return
            
            # Determinar resultado basado en la direcci√≥n
            if se√±al['direccion'] == 'CALL':
                # Para CALL, ganamos si el precio subi√≥
                resultado = 'WIN' if precio_actual > precio_entrada else 'LOSS'
            else:  # PUT/SELL
                # Para PUT, ganamos si el precio baj√≥
                resultado = 'WIN' if precio_actual < precio_entrada else 'LOSS'
            
            # Calcular diferencia en pips
            diferencia = abs(precio_actual - precio_entrada)
            diferencia_porcentaje = (diferencia / precio_entrada) * 100
            
            # Actualizar se√±al con resultado
            se√±al['resultado'] = resultado
            se√±al['hora_resultado'] = datetime.now().strftime('%H:%M')
            se√±al['precio_salida'] = precio_actual
            se√±al['diferencia_pips'] = diferencia
            se√±al['diferencia_porcentaje'] = diferencia_porcentaje
            
            print(f"[SignalScheduler] üìä Resultado: {resultado} | Entrada: {precio_entrada:.5f} | Salida: {precio_actual:.5f} | Diff: {diferencia_porcentaje:.3f}%")
            
            # Actualizar en historial persistente
            self.user_manager.actualizar_resultado_se√±al(se√±al)
            
            # Procesar y notificar resultado
            await self.procesar_resultado_se√±al(se√±al, resultado)
            
        except Exception as e:
            print(f"[SignalScheduler] ‚ùå Error verificando resultado autom√°tico: {e}")
            se√±al['resultado'] = 'ERROR'
            se√±al['motivo_error'] = str(e)
    
    async def obtener_precio_actual(self, symbol: str) -> Optional[float]:
        """Obtiene el precio actual de un mercado desde Quotex"""
        try:
            mm = getattr(self, 'market_manager', None)
            if not mm or not getattr(mm, 'quotex', None):
                print(f"[SignalScheduler] ‚ö†Ô∏è No hay conexi√≥n a Quotex para obtener precio")
                return None
            
            # Intentar obtener precio actual usando diferentes m√©todos
            precio = None
            
            # M√©todo 1: get_candles (m√°s confiable)
            try:
                if hasattr(mm.quotex, 'get_candles'):
                    candles = await mm.quotex.get_candles(symbol, 60)  # 1 minuto
                    if candles and len(candles) > 0:
                        # √öltima vela
                        ultima_vela = candles[-1]
                        precio = ultima_vela.get('close', ultima_vela.get('c'))
                        if precio:
                            print(f"[SignalScheduler] üíπ Precio actual de {symbol}: {precio}")
                            return float(precio)
            except Exception as e:
                print(f"[SignalScheduler] ‚ö†Ô∏è Error con get_candles: {e}")
            
            # M√©todo 2: Obtener de datos de mercado
            try:
                mercados = await mm.obtener_mercados_disponibles()
                for mercado in mercados:
                    if mercado['symbol'] == symbol:
                        precio = mercado.get('precio_actual')
                        if precio:
                            return float(precio)
            except Exception as e:
                print(f"[SignalScheduler] ‚ö†Ô∏è Error obteniendo mercados: {e}")
            
            # M√©todo 3: Obtener datos OHLC recientes
            try:
                df = await mm.obtener_datos_ohlc(symbol, periodos=1)
                if df is not None and len(df) > 0:
                    precio = df['close'].iloc[-1]
                    if precio:
                        return float(precio)
            except Exception as e:
                print(f"[SignalScheduler] ‚ö†Ô∏è Error con OHLC: {e}")
            
            print(f"[SignalScheduler] ‚ùå No se pudo obtener precio actual de {symbol}")
            return None
            
        except Exception as e:
            print(f"[SignalScheduler] ‚ùå Error obteniendo precio actual: {e}")
            return None
    
    async def procesar_resultado_se√±al(self, se√±al: Dict, resultado: str):
        """Procesa el resultado de una se√±al (WIN/LOSS)"""
        se√±al['resultado'] = resultado
        se√±al['hora_resultado'] = datetime.now().strftime('%H:%M')
        
        if resultado == 'WIN':
            frase_exito = random.choice(self.frases_motivacionales['se√±al_exitosa'])
            diferencia = se√±al.get('diferencia_porcentaje', 0)
            mensaje = f"""
{frase_exito}

‚úÖ **SE√ëAL #{se√±al['numero']} - GANADA**
üí± {se√±al['symbol']} | {se√±al['direccion']} | {se√±al['efectividad']:.1f}%
üìä Entrada: {se√±al.get('precio_entrada', 0):.5f} ‚Üí Salida: {se√±al.get('precio_salida', 0):.5f}
üìà Diferencia: {diferencia:.3f}%
üí∞ **Ganancia confirmada!**

¬°Seguimos as√≠, equipo! üöÄ
            """
        else:
            diferencia = se√±al.get('diferencia_porcentaje', 0)
            mensaje = f"""
üìä **SE√ëAL #{se√±al['numero']} - PERDIDA**
üí± {se√±al['symbol']} | {se√±al['direccion']} | {se√±al['efectividad']:.1f}%
üìä Entrada: {se√±al.get('precio_entrada', 0):.5f} ‚Üí Salida: {se√±al.get('precio_salida', 0):.5f}
üìâ Diferencia: {diferencia:.3f}%

No te preocupes, es parte del trading. 
¬°La pr√≥xima ser√° mejor! üí™
            """
        
        await self.enviar_mensaje_a_usuarios(mensaje.strip())
    
    async def generar_resumen_diario(self):
        """Genera y env√≠a el resumen diario"""
        if not self.se√±ales_enviadas_hoy:
            return
        
        # Calcular estad√≠sticas
        total_se√±ales = len(self.se√±ales_enviadas_hoy)
        se√±ales_ganadoras = len([s for s in self.se√±ales_enviadas_hoy if s.get('resultado') == 'WIN'])
        tasa_exito = (se√±ales_ganadoras / total_se√±ales * 100) if total_se√±ales > 0 else 0
        efectividad_promedio = sum(s['efectividad'] for s in self.se√±ales_enviadas_hoy) / total_se√±ales
        
        # Categorizar el d√≠a
        if tasa_exito >= 80:
            categoria = 'fin_dia_excelente'
        elif tasa_exito >= 65:
            categoria = 'fin_dia_bueno'
        else:
            categoria = 'fin_dia_regular'
        
        frase_final = random.choice(self.frases_motivacionales[categoria])
        
        # Generar observaciones
        observaciones = self.generar_observaciones_diarias()
        
        # Calcular efectividad por mercado
        mercados = {}
        for s in self.se√±ales_enviadas_hoy:
            symbol = s['symbol']
            if symbol not in mercados:
                mercados[symbol] = {'total': 0, 'ganadas': 0, 'efectividad': []}
            mercados[symbol]['total'] += 1
            if s.get('resultado') == 'WIN':
                mercados[symbol]['ganadas'] += 1
            mercados[symbol]['efectividad'].append(s['efectividad'])
        resumen_mercados = ''
        for symbol, stats in mercados.items():
            tasa = (stats['ganadas']/stats['total']*100) if stats['total'] else 0
            efect = sum(stats['efectividad'])/stats['total'] if stats['total'] else 0
            newline = "\n"
            resumen_mercados += f"‚Ä¢ {symbol}: {stats['total']} se√±ales | {tasa:.1f}% √©xito | {efect:.1f}% efectividad{newline}"
        
        mensaje_resumen = f"""
üìã **RESUMEN DIARIO - {datetime.now().strftime('%d/%m/%Y')}**

{frase_final}

üìä **ESTAD√çSTICAS DEL D√çA:**
‚Ä¢ üìà **Total de se√±ales:** {total_se√±ales}
‚Ä¢ ‚úÖ **Se√±ales ganadoras:** {se√±ales_ganadoras}
‚Ä¢ üìâ **Se√±ales perdidas:** {total_se√±ales - se√±ales_ganadoras}
‚Ä¢ üéØ **Tasa de √©xito:** {tasa_exito:.1f}%
‚Ä¢ üìä **Efectividad promedio:** {efectividad_promedio:.1f}%
‚Ä¢ üí± **Mercado principal:** {self.mercado_actual['symbol']}
‚Ä¢ üë• **Usuarios activos:** {len(self.user_manager.obtener_usuarios_activos())}

üìà **RENDIMIENTO POR MERCADO:**
{resumen_mercados}
üîç **OBSERVACIONES:**
{observaciones}

üí° **Consejo para ma√±ana:** {self.generar_consejo_siguiente_dia(tasa_exito)}

¬°Gracias por ser parte del equipo CubaYDSignal! üá®üá∫üí™
¬°Nos vemos ma√±ana para m√°s oportunidades! üåÖ
        """
        
        # Usar el nuevo sistema de informe diario completo
        await self.enviar_informe_y_motivacion_diaria()
        print(f"[SignalScheduler] üìã Informe diario completo enviado - {tasa_exito:.1f}% √©xito")
    
    def generar_observaciones_diarias(self) -> str:
        """Genera observaciones inteligentes sobre el d√≠a"""
        observaciones = []
        
        if not self.se√±ales_enviadas_hoy:
            return "‚Ä¢ No se generaron se√±ales v√°lidas hoy."
        
        # An√°lisis por efectividad
        efectividades = [s['efectividad'] for s in self.se√±ales_enviadas_hoy]
        efectividad_max = max(efectividades)
        efectividad_min = min(efectividades)
        
        observaciones.append(f"‚Ä¢ Efectividad m√°xima alcanzada: {efectividad_max:.1f}%")
        observaciones.append(f"‚Ä¢ Rango de efectividad: {efectividad_min:.1f}% - {efectividad_max:.1f}%")
        
        # An√°lisis por direcci√≥n
        calls = len([s for s in self.se√±ales_enviadas_hoy if s['direccion'].upper() == 'CALL'])
        puts = len([s for s in self.se√±ales_enviadas_hoy if s['direccion'].upper() == 'PUT'])
        
        if calls > puts:
            observaciones.append(f"‚Ä¢ Tendencia alcista predominante ({calls} CALL vs {puts} PUT)")
        elif puts > calls:
            observaciones.append(f"‚Ä¢ Tendencia bajista predominante ({puts} PUT vs {calls} CALL)")
        else:
            observaciones.append(f"‚Ä¢ Mercado equilibrado ({calls} CALL, {puts} PUT)")
        
        # An√°lisis temporal
        horas_activas = set(s['hora'].split(':')[0] for s in self.se√±ales_enviadas_hoy)
        observaciones.append(f"‚Ä¢ Horas m√°s activas: {', '.join(sorted(horas_activas))}:XX")
        
        return '\n'.join(observaciones)
    
    def generar_consejo_siguiente_dia(self, tasa_exito: float) -> str:
        """Genera consejo para el siguiente d√≠a"""
        if tasa_exito >= 80:
            return "Mant√©n la disciplina y sigue el plan. ¬°Excelente trabajo!"
        elif tasa_exito >= 65:
            return "Buen rendimiento. Revisa las se√±ales perdidas para mejorar."
        else:
            return "Analiza las condiciones del mercado. Ma√±ana ser√° mejor."
    
    async def enviar_mensaje_a_usuarios(self, mensaje: str):
        """Env√≠a mensaje a todos los usuarios activos"""
        if not self.bot_telegram:
            print(f"[SignalScheduler] üì± Mensaje: {mensaje[:100]}...")
            return
        
        usuarios = self.user_manager.obtener_usuarios_activos()
        for user_id, info in usuarios.items():
            username = info.get('username', '').lower()
            if user_id in self.user_manager.usuarios_bloqueados or (username and username in self.user_manager.usuarios_bloqueados):
                continue
            try:
                await self.bot_telegram.send_message(user_id, mensaje, parse_mode='Markdown')
            except Exception as e:
                print(f"[SignalScheduler] ‚ùå Error enviando a {user_id}: {e}")
    
    async def programar_mensajes_automaticos(self):
        """Programa mensajes autom√°ticos de bienvenida y cierre"""
        ahora = datetime.now()
        # Programar mensaje de bienvenida 7:45 AM
        hora_bienvenida = ahora.replace(hour=7, minute=45, second=0, microsecond=0)
        if ahora > hora_bienvenida:
            hora_bienvenida += timedelta(days=1)
        delay_bienvenida = (hora_bienvenida - ahora).total_seconds()
        asyncio.create_task(self.enviar_mensaje_bienvenida_automatica(delay_bienvenida))
        # Programar mensaje de cierre 20:05 (8:05 PM)
        hora_cierre = ahora.replace(hour=20, minute=5, second=0, microsecond=0)
        if ahora > hora_cierre:
            hora_cierre += timedelta(days=1)
        delay_cierre = (hora_cierre - ahora).total_seconds()
        asyncio.create_task(self.enviar_mensaje_cierre_automatico(delay_cierre))

    async def enviar_mensaje_bienvenida_automatica(self, delay):
        await asyncio.sleep(delay)
        if datetime.now().weekday() < 6:  # Lunes a s√°bado (domingo no operativo)
            frase = random.choice(self.frases_motivacionales['inicio_dia_excelente'])
            mensaje = f"""
üåÑ *¬°Buenos d√≠as, traders!*

{frase}

‚è∞ En 15 minutos inicia el d√≠a de trading (8:00 AM - 8:00 PM).
¬°Prep√°rate para recibir se√±ales de alta efectividad!
"""
            await self.enviar_mensaje_a_usuarios(mensaje.strip())
            print("[SignalScheduler] Mensaje motivador de bienvenida enviado.")

    async def enviar_mensaje_cierre_automatico(self, delay):
        await asyncio.sleep(delay)
        if datetime.now().weekday() < 6:  # Lunes a s√°bado (domingo no operativo)
            efectividad = self.calcular_efectividad_diaria()
            if efectividad >= 85:
                cat = 'fin_dia_excelente'
            elif efectividad >= 75:
                cat = 'fin_dia_bueno'
            else:
                cat = 'fin_dia_regular'
            frase = random.choice(self.frases_motivacionales[cat])
            mensaje = f"""
üåô *¬°Cierre del d√≠a de trading!*

{frase}

üìà Efectividad del d√≠a: {efectividad:.1f}%
¬°Ma√±ana seguimos con m√°s oportunidades!
"""
            await self.enviar_mensaje_a_usuarios(mensaje.strip())
            print("[SignalScheduler] Mensaje de cierre motivador enviado.")

    def calcular_efectividad_diaria(self):
        # Calcula la efectividad del d√≠a (dummy, reemplazar por real)
        if not self.se√±ales_enviadas_hoy:
            return 0.0
        exitos = sum(1 for s in self.se√±ales_enviadas_hoy if s.get('resultado') == 'WIN')
        return 100 * exitos / len(self.se√±ales_enviadas_hoy)

    async def ejecutar_ciclo_diario(self):
        """Ejecuta el ciclo completo de un d√≠a de trading"""
        print("[SignalScheduler] üöÄ Iniciando ciclo diario")
        
        # Esperar un momento para que la conexi√≥n se establezca completamente
        await asyncio.sleep(2)
        
        # Verificar conexi√≥n de m√∫ltiples formas
        try:
            conectado = False
            
            # Verificar m√∫ltiples indicadores de conexi√≥n
            flag_conectado = getattr(self.market_manager, 'conectado', False)
            quotex_activo = getattr(self.market_manager, 'quotex', None) is not None
            mercados_normales = len(getattr(self.market_manager, 'mercados_disponibles', []))
            mercados_otc = len(getattr(self.market_manager, 'mercados_otc', []))
            
            print(f"[SignalScheduler] üîç Verificando conexi√≥n:")
            print(f"  - Flag conectado: {flag_conectado}")
            print(f"  - Quotex activo: {quotex_activo}")
            print(f"  - Mercados normales: {mercados_normales}")
            print(f"  - Mercados OTC: {mercados_otc}")
            
            # Considerar conectado si hay mercados disponibles (m√°s confiable)
            if mercados_normales > 0 or mercados_otc > 0:
                conectado = True
                print(f"[SignalScheduler] ‚úÖ Conexi√≥n verificada: {mercados_normales + mercados_otc} mercados disponibles")
            elif flag_conectado or quotex_activo:
                conectado = True
                print("[SignalScheduler] ‚úÖ Conexi√≥n verificada por flags")
            
            if not conectado:
                self.pausado_por_conexion = True
                print("[SignalScheduler] ‚è∏Ô∏è Ciclo no iniciado: sin conexi√≥n a Quotex")
                return
            else:
                self.pausado_por_conexion = False
        except Exception as e:
            print(f"[SignalScheduler] ‚ö†Ô∏è Error verificando conexi√≥n: {e}")
            pass
        self.running = True
        await self.iniciar_dia_trading()
        await self.programar_se√±ales_del_dia()
        await self.programar_mensajes_automaticos()
        # Notificar al administrador SOLO si hay conexi√≥n y se√±ales programadas
        try:
            if getattr(self.market_manager, 'conectado', False) and self.se√±ales_programadas:
                if getattr(self, 'bot_telegram', None) and hasattr(self.bot_telegram, 'notificar_admin_telegram'):
                    hora = datetime.now().strftime('%H:%M:%S')
                    mensaje = (
                        f"üß† Inicio de an√°lisis de estrategia (conectado a Quotex)\n"
                        f"‚è∞ Hora: {hora}\n"
                        f"üìÖ Ventana operativa: 08:00‚Äì20:00 (Lun‚ÄìS√°b)\n"
                        f"üîî Se enviar√°n pre‚Äëse√±ales ~3 min antes de cada se√±al."
                    )
                    await self.bot_telegram.notificar_admin_telegram(mensaje)
        except Exception:
            pass
        # Ciclo continuo de an√°lisis
        print("[SignalScheduler] üîÑ Iniciando an√°lisis continuo cada 60 segundos...")
        
        while self.running and self.esta_en_horario_operativo():
            ahora = datetime.now()
            
            # An√°lisis continuo: seleccionar mejor mercado cada ciclo EN BACKGROUND
            print(f"[SignalScheduler] üîç Analizando mercados... ({ahora.strftime('%H:%M:%S')})")
            try:
                # Timeout de 60 segundos (aumentado para permitir an√°lisis completo)
                # El an√°lisis se ejecuta en background sin bloquear Telegram
                mejor_mercado = await asyncio.wait_for(
                    self.market_manager.seleccionar_mejor_mercado(),
                    timeout=60.0
                )
            except asyncio.TimeoutError:
                print("[SignalScheduler] ‚è±Ô∏è An√°lisis tard√≥ >60s, saltando ciclo...")
                print("[SignalScheduler] üí° Considera reducir el n√∫mero de mercados a analizar")
                await asyncio.sleep(60)
                continue
            except Exception as e:
                print(f"[SignalScheduler] ‚ùå Error en an√°lisis: {e}")
                await asyncio.sleep(60)
                continue
            
            if mejor_mercado:
                self.mercado_actual = mejor_mercado
                efectividad = mejor_mercado.get('efectividad_calculada', 0)
                print(f"[SignalScheduler] üèÜ Mercado: {mejor_mercado['symbol']} | Payout: {mejor_mercado['payout']}% | Efectividad: {efectividad:.1f}%")
                
                # Si la efectividad es >= 80%, generar y enviar se√±al
                if efectividad >= 80:
                    print(f"[SignalScheduler] ‚úÖ Se√±al v√°lida detectada (‚â•80% efectividad)")
                    se√±al = await self.ejecutar_analisis_se√±al()
                    if se√±al:
                        await self.enviar_se√±al(se√±al)
                        # Esperar 5 minutos despu√©s de enviar una se√±al para no saturar
                        print("[SignalScheduler] ‚è≥ Esperando 5 minutos tras enviar se√±al...")
                        await asyncio.sleep(300)
                else:
                    print(f"[SignalScheduler] ‚ö†Ô∏è Efectividad insuficiente ({efectividad:.1f}% < 80%)")
            else:
                print("[SignalScheduler] ‚ùå No se encontr√≥ mercado con efectividad >= 80%")
            
            # Esperar 60 segundos antes del pr√≥ximo an√°lisis
            # Usar sleep cortos para permitir que el bot responda a comandos
            if self.running and self.esta_en_horario_operativo():
                print("[SignalScheduler] ‚è∏Ô∏è Esperando 60 segundos para pr√≥ximo an√°lisis...")
                # Dividir en sleeps de 5 segundos para mejor respuesta
                for _ in range(12):  # 12 x 5 = 60 segundos
                    if not self.running:
                        break
                    await asyncio.sleep(5)
        await self.generar_resumen_diario()
        print("[SignalScheduler] üõë Fin del ciclo diario")
        self.running = False

        print("[SignalScheduler] üèÅ Ciclo diario completado")
    
    def detener(self):
        """Detiene el scheduler"""
        self.running = False
        print("[SignalScheduler] ‚èπÔ∏è Scheduler detenido")
    
    async def forzar_inicio_analisis(self):
        """Fuerza el inicio del an√°lisis (usado cuando se activa conexi√≥n forzada)"""
        import asyncio
        
        # Si ya est√° corriendo, detenerlo primero
        if self.running:
            print("[SignalScheduler] ‚ö†Ô∏è Scheduler ya corriendo - Reiniciando con modo forzado...")
            self.running = False
            await asyncio.sleep(1)  # Dar tiempo para que se detenga
        
        print("[SignalScheduler] üîì Iniciando an√°lisis forzado (modo forzado activo)...")
        
        # Esperar un momento para que los mercados se carguen
        await asyncio.sleep(2)
        
        self.running = True
        
        # Crear tarea as√≠ncrona para ejecutar el ciclo
        asyncio.create_task(self.ejecutar_ciclo_diario())
        print("[SignalScheduler] ‚úÖ An√°lisis forzado iniciado")
    
    def configurar_market_manager(self, market_manager):
        """Configura la referencia al MarketManager"""
        self.market_manager = market_manager
        print("[SignalScheduler] ‚úÖ MarketManager configurado")
    
    def configurar_user_manager(self, user_manager):
        """Configura la referencia al UserManager"""
        self.user_manager = user_manager
        print("[SignalScheduler] ‚úÖ UserManager configurado")
    
    def configurar_bot_telegram(self, bot_telegram):
        """Configura la referencia al bot de Telegram"""
        self.bot_telegram = bot_telegram
        print("[SignalScheduler] ‚úÖ Bot de Telegram configurado")
    
    def es_horario_operativo(self) -> bool:
        """Verifica si estamos en horario operativo (8:00-20:00, Lun-S√°b)"""
        ahora = datetime.now()
        
        # Si hay conexi√≥n forzada activa, siempre retornar True
        if hasattr(self, 'market_manager') and self.market_manager:
            if self.market_manager.esta_en_modo_forzado():
                return True
        
        # Verificar override temporal
        if self._override_until and ahora < self._override_until:
            return True
        
        # Verificar d√≠a de la semana (0=Lunes, 6=Domingo)
        dia_semana = ahora.weekday()
        if dia_semana == 6:  # Domingo
            return False
        
        # Verificar horario (8:00 AM - 8:00 PM)
        hora = ahora.hour
        return 8 <= hora < 20
    
    def esta_en_horario_operativo(self) -> bool:
        """Alias para compatibilidad - llama a es_horario_operativo()"""
        return self.es_horario_operativo()
    
    async def iniciar_scheduler(self):
        """Inicia el scheduler de se√±ales"""
        print("[SignalScheduler] üöÄ Iniciando scheduler de se√±ales...")
        self.running = True
        
        # Verificar horario operativo
        ahora = datetime.now()
        if self._override_until and ahora < self._override_until:
            print(f"[SignalScheduler] ‚ö° Override activo hasta {self._override_until}")
            print("[SignalScheduler] üîÑ Iniciando ciclo diario...")
            await self.ejecutar_ciclo_diario()
        else:
            # Verificar si estamos en horario operativo (8:00-20:00, Lun-S√°b)
            if self.es_horario_operativo():
                print("[SignalScheduler] ‚úÖ En horario operativo")
                print("[SignalScheduler] üîÑ Iniciando ciclo diario...")
                await self.ejecutar_ciclo_diario()
            else:
                print("[SignalScheduler] ‚è∞ Fuera de horario operativo")
                print("[SignalScheduler] üí§ Esperando horario operativo...")
    
    async def ejecutar_operacion_automatica(self, se√±al: Dict):
        """Ejecuta autom√°ticamente una operaci√≥n en Quotex seg√∫n la se√±al"""
        try:
            # Obtener configuraci√≥n de trading
            modo = getattr(self.bot_telegram, '_trading_modo', None)
            monto = getattr(self.bot_telegram, '_trading_monto', 0)
            
            if not modo or monto <= 0:
                print(f"[Trading] ‚ö†Ô∏è Configuraci√≥n inv√°lida - Modo: {modo}, Monto: {monto}")
                return
            
            # Obtener datos de la se√±al
            symbol = se√±al.get('symbol', 'EURUSD')
            direccion = se√±al.get('decision', '').upper()  # CALL o PUT
            efectividad = se√±al.get('efectividad_total', 0)
            
            # Validar que la se√±al sea v√°lida
            if direccion not in ['CALL', 'PUT']:
                print(f"[Trading] ‚ö†Ô∏è Direcci√≥n inv√°lida: {direccion}")
                return
            
            if efectividad < 80:
                print(f"[Trading] ‚ö†Ô∏è Efectividad muy baja: {efectividad}%")
                return
            
            print(f"[Trading] üéØ Ejecutando operaci√≥n autom√°tica:")
            print(f"[Trading]    Modo: {modo}")
            print(f"[Trading]    Symbol: {symbol}")
            print(f"[Trading]    Direcci√≥n: {direccion}")
            print(f"[Trading]    Monto: ${monto}")
            print(f"[Trading]    Efectividad: {efectividad}%")
            
            # Verificar conexi√≥n a Quotex
            if not self.market_manager or not hasattr(self.market_manager, 'quotex'):
                print(f"[Trading] ‚ùå No hay conexi√≥n a Quotex")
                await self._notificar_admin_trading(
                    f"‚ùå **Operaci√≥n NO Ejecutada**\n\n"
                    f"No hay conexi√≥n a Quotex\n"
                    f"Se√±al: {symbol} {direccion}"
                )
                return
            
            quotex = self.market_manager.quotex
            
            # Cambiar a cuenta DEMO o REAL seg√∫n configuraci√≥n
            try:
                if modo == "DEMO":
                    await quotex.change_account("PRACTICE")
                    print(f"[Trading] üéÆ Cambiado a cuenta DEMO")
                else:
                    await quotex.change_account("REAL")
                    print(f"[Trading] üíé Cambiado a cuenta REAL")
            except Exception as e:
                print(f"[Trading] ‚ö†Ô∏è Error cambiando cuenta: {e}")
            
            # Ejecutar la operaci√≥n
            try:
                # Convertir s√≠mbolo al formato de Quotex
                asset = symbol.replace('/', '').replace('_OTC', '_otc')
                
                # Duraci√≥n de la operaci√≥n (5 minutos = 300 segundos)
                duracion = 300
                
                # Ejecutar operaci√≥n
                check, order_id = await quotex.buy(
                    amount=monto,
                    asset=asset,
                    direction=direccion.lower(),  # 'call' o 'put'
                    duration=duracion
                )
                
                if check:
                    # Incrementar contador de operaciones
                    operaciones_actuales = getattr(self.bot_telegram, '_trading_operaciones_hoy', 0)
                    self.bot_telegram._trading_operaciones_hoy = operaciones_actuales + 1
                    
                    print(f"[Trading] ‚úÖ Operaci√≥n ejecutada exitosamente - ID: {order_id}")
                    
                    # Notificar al admin
                    await self._notificar_admin_trading(
                        f"‚úÖ **Operaci√≥n Ejecutada**\n\n"
                        f"üéØ **Detalles:**\n"
                        f"‚Ä¢ Modo: {modo}\n"
                        f"‚Ä¢ Symbol: {symbol}\n"
                        f"‚Ä¢ Direcci√≥n: {direccion}\n"
                        f"‚Ä¢ Monto: ${monto:.2f}\n"
                        f"‚Ä¢ Efectividad: {efectividad:.1f}%\n"
                        f"‚Ä¢ Order ID: {order_id}\n"
                        f"‚Ä¢ Duraci√≥n: 5 minutos\n\n"
                        f"‚è∞ Resultado en 5 minutos"
                    )
                else:
                    print(f"[Trading] ‚ùå Error ejecutando operaci√≥n")
                    await self._notificar_admin_trading(
                        f"‚ùå **Error Ejecutando Operaci√≥n**\n\n"
                        f"Symbol: {symbol}\n"
                        f"Direcci√≥n: {direccion}\n"
                        f"Monto: ${monto:.2f}\n\n"
                        f"Verifica tu saldo y conexi√≥n"
                    )
                    
            except Exception as e:
                print(f"[Trading] ‚ùå Excepci√≥n ejecutando operaci√≥n: {e}")
                await self._notificar_admin_trading(
                    f"‚ùå **Excepci√≥n en Operaci√≥n**\n\n"
                    f"Error: {str(e)}\n"
                    f"Symbol: {symbol}\n"
                    f"Direcci√≥n: {direccion}"
                )
                
        except Exception as e:
            print(f"[Trading] ‚ùå Error general en ejecutar_operacion_automatica: {e}")
    
    async def _notificar_admin_trading(self, mensaje: str):
        """Notifica al administrador sobre operaciones de trading"""
        try:
            if self.bot_telegram and hasattr(self.bot_telegram, 'application'):
                # Obtener ID del admin
                admin_ids = self.user_manager.obtener_administradores()
                if admin_ids:
                    admin_id = admin_ids[0]
                    await self.bot_telegram.application.bot.send_message(
                        chat_id=admin_id,
                        text=mensaje,
                        parse_mode='Markdown'
                    )
        except Exception as e:
            print(f"[Trading] ‚ö†Ô∏è Error notificando admin: {e}")

# Funci√≥n principal
async def ejecutar_bot_completo():
    """Funci√≥n principal para ejecutar el bot completo"""
    scheduler = SignalScheduler()
    
    # Conectar a Quotex
    try:
        import os
        email = os.getenv("QUOTEX_EMAIL")
        password = os.getenv("QUOTEX_PASSWORD")
    except Exception:
        email = None
        password = None
    if await scheduler.market_manager.conectar_quotex(email, password):
        await scheduler.ejecutar_ciclo_diario()
    else:
        print("‚ùå No se pudo conectar a Quotex")

if __name__ == "__main__":
    # Ejecutar bot
    asyncio.run(ejecutar_bot_completo())
            
            if not modo or monto <= 0:
                print(f"[Trading] ‚ö†Ô∏è Configuraci√≥n inv√°lida - Modo: {modo}, Monto: {monto}")
                return
            
            # Obtener datos de la se√±al
            symbol = se√±al.get('symbol', 'EURUSD')
            direccion = se√±al.get('decision', '').upper()  # CALL o PUT
            efectividad = se√±al.get('efectividad_total', 0)
            
            # Validar que la se√±al sea v√°lida
            if direccion not in ['CALL', 'PUT']:
                print(f"[Trading] ‚ö†Ô∏è Direcci√≥n inv√°lida: {direccion}")
                return
            
            if efectividad < 80:
                print(f"[Trading] ‚ö†Ô∏è Efectividad muy baja: {efectividad}%")
                return
            
            print(f"[Trading] üéØ Ejecutando operaci√≥n autom√°tica:")
            print(f"[Trading]    Modo: {modo}")
            print(f"[Trading]    Symbol: {symbol}")
            print(f"[Trading]    Direcci√≥n: {direccion}")
            print(f"[Trading]    Monto: ${monto}")
            print(f"[Trading]    Efectividad: {efectividad}%")
            
            # Verificar conexi√≥n a Quotex
            if not self.market_manager or not hasattr(self.market_manager, 'quotex'):
                print(f"[Trading] ‚ùå No hay conexi√≥n a Quotex")
                await self._notificar_admin_trading(
                    f"‚ùå **Operaci√≥n NO Ejecutada**\n\n"
                    f"No hay conexi√≥n a Quotex\n"
                    f"Se√±al: {symbol} {direccion}"
                )
                return
            
            quotex = self.market_manager.quotex
            
            # Cambiar a cuenta DEMO o REAL seg√∫n configuraci√≥n
            try:
                if modo == "DEMO":
                    await quotex.change_account("PRACTICE")
                    print(f"[Trading] üéÆ Cambiado a cuenta DEMO")
                else:
                    await quotex.change_account("REAL")
                    print(f"[Trading] üíé Cambiado a cuenta REAL")
            except Exception as e:
                print(f"[Trading] ‚ö†Ô∏è Error cambiando cuenta: {e}")
            
            # Ejecutar la operaci√≥n
            try:
                # Convertir s√≠mbolo al formato de Quotex
                asset = symbol.replace('/', '').replace('_OTC', '_otc')
                
                # Duraci√≥n de la operaci√≥n (5 minutos = 300 segundos)
                duracion = 300
                
                # Ejecutar operaci√≥n
                check, order_id = await quotex.buy(
                    amount=monto,
                    asset=asset,
                    direction=direccion.lower(),  # 'call' o 'put'
                    duration=duracion
                )
                
                if check:
                    # Incrementar contador de operaciones
                    operaciones_actuales = getattr(self.bot_telegram, '_trading_operaciones_hoy', 0)
                    self.bot_telegram._trading_operaciones_hoy = operaciones_actuales + 1
                    
                    print(f"[Trading] ‚úÖ Operaci√≥n ejecutada exitosamente - ID: {order_id}")
                    
                    # Notificar al admin
                    await self._notificar_admin_trading(
                        f"‚úÖ **Operaci√≥n Ejecutada**\n\n"
                        f"üéØ **Detalles:**\n"
                        f"‚Ä¢ Modo: {modo}\n"
                        f"‚Ä¢ Symbol: {symbol}\n"
                        f"‚Ä¢ Direcci√≥n: {direccion}\n"
                        f"‚Ä¢ Monto: ${monto:.2f}\n"
                        f"‚Ä¢ Efectividad: {efectividad:.1f}%\n"
                        f"‚Ä¢ Order ID: {order_id}\n"
                        f"‚Ä¢ Duraci√≥n: 5 minutos\n\n"
                        f"‚è∞ Resultado en 5 minutos"
                    )
                else:
                    print(f"[Trading] ‚ùå Error ejecutando operaci√≥n")
                    await self._notificar_admin_trading(
                        f"‚ùå **Error Ejecutando Operaci√≥n**\n\n"
                        f"Symbol: {symbol}\n"
                        f"Direcci√≥n: {direccion}\n"
                        f"Monto: ${monto:.2f}\n\n"
                        f"Verifica tu saldo y conexi√≥n"
                    )
                    
            except Exception as e:
                print(f"[Trading] ‚ùå Excepci√≥n ejecutando operaci√≥n: {e}")
                await self._notificar_admin_trading(
                    f"‚ùå **Excepci√≥n en Operaci√≥n**\n\n"
                    f"Error: {str(e)}\n"
                    f"Symbol: {symbol}\n"
                    f"Direcci√≥n: {direccion}"
                )
                
        except Exception as e:
            print(f"[Trading] ‚ùå Error general en ejecutar_operacion_automatica: {e}")
    
    async def _notificar_admin_trading(self, mensaje: str):
        """Notifica al administrador sobre operaciones de trading"""
        try:
            if self.bot_telegram and hasattr(self.bot_telegram, 'application'):
                # Obtener ID del admin
                admin_ids = self.user_manager.obtener_administradores()
                if admin_ids:
                    admin_id = admin_ids[0]
                    await self.bot_telegram.application.bot.send_message(
                        chat_id=admin_id,
                        text=mensaje,
                        parse_mode='Markdown'
                    )
        except Exception as e:
            print(f"[Trading] ‚ö†Ô∏è Error notificando admin: {e}")
    else:
        print("‚ùå No se pudo conectar a Quotex")

if __name__ == "__main__":
    # Ejecutar bot
    asyncio.run(ejecutar_bot_completo())
