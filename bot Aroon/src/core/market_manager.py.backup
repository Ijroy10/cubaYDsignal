"""
MÃ“DULO DE GESTIÃ“N DE MERCADOS MÃšLTIPLES
Maneja la selecciÃ³n automÃ¡tica de mercados basada en:
- Payout â‰¥ 85%
- Horarios de noticias
- Mercados OTC vs normales
- AnÃ¡lisis de efectividad diaria por mercado
"""

import asyncio
import json
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import pandas as pd
import numpy as np
from dataclasses import dataclass
import requests
from loguru import logger
import pytz
# Importar pyquotex (WebSocket puro, sin navegador)
try:
    from pyquotex.api import QuotexAPI
    QUOTEX_DISPONIBLE = True
    logger.info("âœ… pyquotex cargado correctamente (conexiÃ³n WebSocket sin navegador)")
except ImportError as e:
    logger.warning(f"âš ï¸ pyquotex no disponible: {e}. El bot funcionarÃ¡ en modo sin conexiÃ³n a Quotex.")
    logger.info("ðŸ’¡ Instala pyquotex con: python -m pip install git+https://github.com/cleitonleonel/pyquotex.git")
    QuotexAPI = None
    QUOTEX_DISPONIBLE = False



class MarketManager:
    def __init__(self):
        self.quotex = None
        self.mercados_disponibles = []
        self.mercados_otc = []
        self.efectividad_diaria = {}
        self.horarios_noticias = self.cargar_horarios_noticias()
        self.payout_minimo = 80.0
        self.data_dir = "data"
        os.makedirs(self.data_dir, exist_ok=True)
        self.last_connect_error = None
        self.conectado = False
        # Estado de conexiÃ³n para health-checks
        self.tstamp_conectado = None
        self.fallos_assets = 0
        # NotificaciÃ³n visual (dashboard) ya enviada
        self.notificado_visual = False
        # Control de bloqueos 403
        self.ultimo_bloqueo_403 = None
        self.tiempo_pausa_403 = 30 * 60  # 30 minutos en segundos
        # Control de conexiÃ³n forzada por admin
        self.conexion_forzada = False  # Si True, ignora horarios
        # Control de desconexiÃ³n manual
        self.desconexion_manual = False  # Si True, NO reconectar automÃ¡ticamente
        logger.info(f"MarketManager inicializado en modo REAL. Esperando conexiÃ³n a Quotex para obtener mercados disponibles...")
    
    # MÃ‰TODOS DE SIMULACIÃ“N ELIMINADOS - SOLO DATOS REALES DE QUOTEX
    # Todos los mercados y datos provienen Ãºnicamente de la API real de Quotex
        
    async def _post_connection_success(self, telegram_bot=None, signal_scheduler=None):
        """Acciones a realizar tras una conexiÃ³n exitosa."""
        self.conectado = True
        self.last_connect_error = None
        self.tstamp_conectado = datetime.now()
        self.fallos_assets = 0
        # Mensaje uniforme con hora (evitar duplicado si ya notificamos visualmente)
        hora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        msg_ok = f"[QX]  Conectado correctamente a Quotex\n Hora: {hora}"
        if not self.notificado_visual:
            logger.info(msg_ok)

        try:
            # Cargar/actualizar mercados disponibles tras conectar
            await self.obtener_mercados_disponibles()
            if telegram_bot and not self.notificado_visual:
                await telegram_bot.notificar_admin_telegram(msg_ok)
            
            # Iniciar estrategia automÃ¡ticamente despuÃ©s de conectar
            if signal_scheduler:
                logger.info("ðŸš€ Iniciando estrategia de seÃ±ales automÃ¡ticamente...")
                try:
                    # Si el scheduler no estÃ¡ corriendo, iniciarlo
                    if not getattr(signal_scheduler, 'running', False):
                        await signal_scheduler.iniciar_scheduler()
                        logger.info("âœ… Scheduler de seÃ±ales iniciado")
                    else:
                        # Si ya estÃ¡ corriendo, iniciar el flujo del dÃ­a
                        await signal_scheduler.iniciar_dia_trading()
                        await signal_scheduler.programar_seÃ±ales_del_dia()
                        logger.info("âœ… Estrategia de seÃ±ales activada")
                    
                    if telegram_bot:
                        await telegram_bot.notificar_admin_telegram(
                            "ðŸŽ¯ Estrategia de seÃ±ales iniciada automÃ¡ticamente tras conexiÃ³n a Quotex"
                        )
                except Exception as e:
                    logger.error(f"Error iniciando estrategia: {e}")
                    
        except Exception as e:
            logger.error(f"Error en acciones post-conexiÃ³n: {e}")

    async def _notificar_fallo_conexion(self, telegram_bot, exception=None):
        """Notifica al administrador sobre un fallo de conexiÃ³n."""
        self.conectado = False
        error_msg = str(exception).lower() if exception else ""
        hora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Detectar error 403 de Cloudflare especÃ­ficamente
        if '403' in error_msg or 'cloudflare' in error_msg or 'forbidden' in error_msg:
            self.last_connect_error = 'cloudflare_403'
            # Marcar tiempo del Ãºltimo bloqueo para evitar reintentos inmediatos
            self.ultimo_bloqueo_403 = datetime.now()
            msg = (
                f"ðŸš¨ [QX] BLOQUEO CLOUDFLARE DETECTADO\n"
                f"ðŸ•°ï¸ Hora: {hora}\n\n"
                f"ðŸš« Quotex ha bloqueado la conexiÃ³n WebSocket.\n\n"
                f"ðŸ“ DIAGNÃ“STICO:\n"
                f"â€¢ Login web: âœ… EXITOSO\n"
                f"â€¢ WebSocket: âŒ BLOQUEADO (403)\n"
                f"â€¢ Causa: Cloudflare detecta comportamiento automatizado\n\n"
                f"ðŸ”§ SOLUCIONES RECOMENDADAS:\n"
                f"1ï¸âƒ£ Cambia a red residencial (hotspot mÃ³vil)\n"
                f"2ï¸âƒ£ Evita VPNs de datacenter\n"
                f"3ï¸âƒ£ Espera 30-60 minutos antes de reintentar\n"
                f"4ï¸âƒ£ Usa navegaciÃ³n manual en Quotex por unos minutos\n\n"
                f"â¸ï¸ El bot pausarÃ¡ intentos por 30 minutos."
            )
        elif 'unable to extract ssid token' in error_msg:
            self.last_connect_error = 'ssid_token_error'
            msg = (
                f"[QX]  Error de login en Quotex\n Hora: {hora}\n\n"
                "No se pudo obtener el token de sesiÃ³n. Causas probables:\n"
                "1. Credenciales invÃ¡lidas: Revisa QUOTEX_EMAIL y QUOTEX_PASSWORD.\n"
                "2. Bloqueo por CAPTCHA: Inicia sesiÃ³n manualmente para descartarlo.\n\n"
                "El bot reintentarÃ¡ conectarse mÃ¡s tarde."
            )
        elif exception:
            self.last_connect_error = str(exception)
            msg = (
                f"[QX]  Error de conexiÃ³n en Quotex\n Hora: {hora}\n"
                f"âŒ Detalle: {str(exception)[:200]}\n"
                "Se reintentarÃ¡ la conexiÃ³n automÃ¡ticamente."
            )
        else:
            self.last_connect_error = "Authentication failed"
            msg = (
                f"[QX]  Error de autenticaciÃ³n en Quotex\n Hora: {hora}\n"
                "â€¢ Credenciales invÃ¡lidas o cuenta bloqueada.\n"
                "â€¢ Revisa las variables QUOTEX_EMAIL y QUOTEX_PASSWORD."
            )

        logger.error(f"Fallo de conexiÃ³n Quotex: {self.last_connect_error}")
        if telegram_bot:
            try:
                await telegram_bot.notificar_admin_telegram(msg)
            except Exception as e_notify:
                logger.warning(f"No se pudo notificar error de Quotex al admin: {e_notify}")

    async def _wait_connected(self, timeout: int = 60) -> bool:
        """Espera activa hasta que la sesiÃ³n estÃ© completamente lista.
        
        Para pyquotex, simplemente esperamos unos segundos para que
        la autenticaciÃ³n se complete. Los instrumentos se cargarÃ¡n
        cuando se necesiten.
        """
        # Espera breve para permitir autenticaciÃ³n
        logger.info("ðŸ” Verificando conexiÃ³n a Quotex...")
        await asyncio.sleep(5)
        
        # Verificar que la instancia de Quotex existe
        if not self.quotex:
            logger.error("âŒ No hay instancia de Quotex")
            return False
        
        # Con pyquotex, si el WebSocket se conectÃ³, la sesiÃ³n estÃ¡ lista
        logger.info("âœ… ConexiÃ³n WebSocket activa y autenticada")
        logger.info("âœ… ConexiÃ³n a Quotex completamente verificada")
        return True

    def verificar_estado_conexion(self) -> dict:
        """Devuelve un diagnÃ³stico completo del estado de conexiÃ³n a Quotex.
        
        Returns:
            dict: Estado detallado con todos los criterios de conexiÃ³n
        """
        estado = {
            "conectado": False,
            "quotex_instance": False,
            "websocket_connected": False,
            "api_available": False,
            "ssid_present": False,
            "no_websocket_errors": False,
            "thread_alive": False,
            "balance_available": False,
            "internal_check": False,
            "balance_value": None,
            "error_details": None
        }
        
        try:
            # Verificar instancia de Quotex
            if self.quotex:
                estado["quotex_instance"] = True
                
                # Verificar WebSocket conectado
                if getattr(self.quotex, "is_connected", False):
                    estado["websocket_connected"] = True
                
                # Verificar API interna
                api = getattr(self.quotex, "api", None)
                if api:
                    estado["api_available"] = True
                    
                    # Verificar SSID
                    if getattr(api, "SSID", None):
                        estado["ssid_present"] = True
                    
                    # Verificar errores de WebSocket
                    if not getattr(api, "check_websocket_if_error", True):
                        estado["no_websocket_errors"] = True
                    else:
                        estado["error_details"] = getattr(api, "websocket_error_reason", "Unknown error")
                    
                    # Verificar thread de WebSocket
                    ws_thread = getattr(api, "websocket_thread", None)
                    if ws_thread and ws_thread.is_alive():
                        estado["thread_alive"] = True
                    
                    # Verificar balance
                    try:
                        bal = getattr(api.profile, "balance", None) if hasattr(api, 'profile') else None
                        if bal is None:
                            bal = getattr(api, "account_balance", None)
                        
                        if isinstance(bal, (int, float)):
                            estado["balance_available"] = True
                            estado["balance_value"] = bal
                    except Exception:
                        pass
                    
                    # VerificaciÃ³n interna
                    try:
                        if hasattr(api, 'esta_dentro'):
                            estado["internal_check"] = api.esta_dentro()
                        else:
                            estado["internal_check"] = True  # No disponible, asumir OK
                    except Exception:
                        estado["internal_check"] = False
            
            # Determinar estado general
            estado["conectado"] = all([
                estado["quotex_instance"],
                estado["websocket_connected"],
                estado["api_available"],
                estado["ssid_present"],
                estado["no_websocket_errors"],
                estado["thread_alive"],
                estado["balance_available"],
                estado["internal_check"]
            ])
            
        except Exception as e:
            estado["error_details"] = str(e)
        
        return estado

    async def conectar_quotex(self, email: str, password: str, telegram_bot=None, signal_scheduler=None) -> bool:
        """Conecta a Quotex usando pyquotex (WebSocket puro, sin navegador)."""
        # Resetear bandera de desconexiÃ³n manual al conectar manualmente
        self.desconexion_manual = False
        
        if self.conectado:
            logger.info("Ya se encuentra conectado a Quotex.")
            return True

        logger.info(f"[Quotex] Intentando conectar con usuario: {email}")
        logger.info("Conectando vÃ­a WebSocket (pyquotex - sin navegador)...")
        
        try:
            # Crear cliente pyquotex (WebSocket puro, sin navegador)
            logger.info("Iniciando conexiÃ³n WebSocket...")
            
            # QuotexAPI requiere: host, username, password, lang
            host = "qxbroker.com"
            lang = "es"  # EspaÃ±ol
            
            self.quotex = QuotexAPI(
                host=host,
                username=email,
                password=password,
                lang=lang
            )
            
            # Conectar usando pyquotex
            # is_demo: True para cuenta demo, False para cuenta real
            is_demo = False  # Cuenta REAL
            check, reason = await self.quotex.connect(is_demo)
            
            if not check:
                error_msg = f"Fallo en conexiÃ³n: {reason}"
                logger.error(f"âŒ {error_msg}")
                await self._notificar_fallo_conexion(telegram_bot, Exception(error_msg))
                return False
            
            logger.info(f"âœ… ConexiÃ³n WebSocket establecida: {reason}")
            
            # Esperar autenticaciÃ³n y activos disponibles
            logger.info("Esperando autenticaciÃ³n y activos disponibles (mÃ¡x. 60 segundos)...")
            await self._wait_connected(timeout=60)
            
            logger.info("âœ… ConexiÃ³n confirmada con activos disponibles")
            
            # Ejecutar acciones post-conexiÃ³n (incluye inicio automÃ¡tico de estrategia)
            await self._post_connection_success(telegram_bot, signal_scheduler)
            
            return True
                
        except Exception as e:
            logger.error(f"âŒ Error en conexiÃ³n pyquotex: {e}")
            await self._notificar_fallo_conexion(telegram_bot, e)
            return False

    async def desconectar_quotex(self):
        """Desconecta de Quotex limpiamente y libera recursos."""
        # Marcar como desconexiÃ³n manual para evitar reconexiÃ³n automÃ¡tica
        self.desconexion_manual = True
        
        if self.quotex and self.conectado:
            logger.info("Desconectando de Quotex...")
            try:
                # pyquotex usa close() para cerrar la conexiÃ³n WebSocket
                await self.quotex.close()
            except Exception as e:
                logger.error(f"Error al desconectar de Quotex: {e}")
            finally:
                self.quotex = None
                self.conectado = False
                self.tstamp_conectado = None
                self.mercados_disponibles = []
                self.mercados_otc = []
                # Desactivar conexiÃ³n forzada al desconectar manualmente
                self.conexion_forzada = False
                logger.info("DesconexiÃ³n de Quotex completada. ConexiÃ³n forzada desactivada.")
        else:
            logger.info("No hay sesiÃ³n activa para cerrar.")
            # Desactivar conexiÃ³n forzada aunque no haya sesiÃ³n
            self.conexion_forzada = False
    
    def activar_conexion_forzada(self):
        """Activa el modo de conexiÃ³n forzada (ignora horarios)."""
        self.conexion_forzada = True
        logger.info("ðŸ”“ ConexiÃ³n forzada ACTIVADA - Se ignorarÃ¡n restricciones de horario")
    
    def desactivar_conexion_forzada(self):
        """Desactiva el modo de conexiÃ³n forzada."""
        self.conexion_forzada = False
        logger.info("ðŸ”’ ConexiÃ³n forzada DESACTIVADA - Se respetarÃ¡n horarios normales")
    
    def esta_en_modo_forzado(self) -> bool:
        """Verifica si estÃ¡ en modo de conexiÃ³n forzada."""
        return self.conexion_forzada
    
    def _debe_esperar_por_bloqueo_403(self) -> bool:
        """Verifica si debe esperar antes de intentar reconectar debido a un bloqueo 403 reciente."""
        if not self.ultimo_bloqueo_403:
            return False
        
        tiempo_transcurrido = (datetime.now() - self.ultimo_bloqueo_403).total_seconds()
        return tiempo_transcurrido < self.tiempo_pausa_403
    
    def _tiempo_restante_bloqueo_403(self) -> int:
        """Devuelve el tiempo restante en segundos antes de poder intentar reconectar tras bloqueo 403."""
        if not self.ultimo_bloqueo_403:
            return 0
        
        tiempo_transcurrido = (datetime.now() - self.ultimo_bloqueo_403).total_seconds()
        tiempo_restante = max(0, self.tiempo_pausa_403 - tiempo_transcurrido)
        return int(tiempo_restante)
    
    async def esta_listo_para_operar(self) -> Dict[str, any]:
        """Verifica de manera integral si el bot estÃ¡ completamente listo para ejecutar estrategias.
        
        Returns:
            Dict con estado detallado y criterios de verificaciÃ³n
        """
        resultado = {
            "listo": False,
            "timestamp": datetime.now().isoformat(),
            "criterios": {
                "conexion_quotex": False,
                "websocket_activo": False,
                "balance_disponible": False,
                "mercados_cargados": False,
                "sin_errores_criticos": False,
                "horario_operativo": False,
                "sin_bloqueo_403": False
            },
            "detalles": {},
            "recomendaciones": []
        }
        
        try:
            # 1. Verificar conexiÃ³n bÃ¡sica a Quotex
            if self.quotex and self.conectado:
                resultado["criterios"]["conexion_quotex"] = True
                resultado["detalles"]["conexion"] = "Instancia de Quotex activa y marcada como conectada"
            else:
                resultado["detalles"]["conexion"] = "No hay instancia de Quotex o no estÃ¡ marcada como conectada"
                resultado["recomendaciones"].append("Ejecutar conectar_quotex() para establecer conexiÃ³n")
            
            # 2. Verificar WebSocket activo y sin errores
            if self.quotex and hasattr(self.quotex, 'api'):
                api = self.quotex.api
                
                # WebSocket conectado
                ws_connected = getattr(api, 'websocket_client', None) is not None
                if ws_connected:
                    resultado["criterios"]["websocket_activo"] = True
                    resultado["detalles"]["websocket"] = "WebSocket cliente activo"
                else:
                    resultado["detalles"]["websocket"] = "WebSocket cliente no disponible"
                    resultado["recomendaciones"].append("Reconectar WebSocket")
                
                # Sin errores crÃ­ticos
                no_errors = not getattr(api, 'check_websocket_if_error', True)
                if no_errors:
                    resultado["criterios"]["sin_errores_criticos"] = True
                    resultado["detalles"]["errores"] = "Sin errores WebSocket detectados"
                else:
                    resultado["detalles"]["errores"] = "Errores WebSocket detectados"
                    resultado["recomendaciones"].append("Resolver errores WebSocket antes de operar")
            else:
                resultado["detalles"]["websocket"] = "API de Quotex no disponible"
                resultado["recomendaciones"].append("Verificar inicializaciÃ³n de la API")
            
            # 3. Verificar balance disponible
            try:
                if self.quotex:
                    balance = await self.quotex.get_balance()
                    if balance is not None and isinstance(balance, (int, float)) and balance > 0:
                        resultado["criterios"]["balance_disponible"] = True
                        resultado["detalles"]["balance"] = f"Balance: ${balance}"
                    else:
                        resultado["detalles"]["balance"] = f"Balance no vÃ¡lido: {balance}"
                        resultado["recomendaciones"].append("Verificar balance de la cuenta")
                else:
                    resultado["detalles"]["balance"] = "No se puede verificar balance sin conexiÃ³n"
            except Exception as e:
                resultado["detalles"]["balance"] = f"Error obteniendo balance: {e}"
                resultado["recomendaciones"].append("Resolver problemas de acceso al balance")
            
            # 4. Verificar mercados cargados
            mercados_count = len(self.mercados_disponibles)
            if mercados_count > 0:
                resultado["criterios"]["mercados_cargados"] = True
                resultado["detalles"]["mercados"] = f"{mercados_count} mercados disponibles"
            else:
                resultado["detalles"]["mercados"] = "No hay mercados cargados"
                resultado["recomendaciones"].append("Ejecutar obtener_mercados_disponibles()")
            
            # 5. Verificar horario operativo (evitar fines de semana y horarios no operativos)
            ahora = datetime.now()
            es_fin_semana = ahora.weekday() >= 5  # SÃ¡bado (5) o Domingo (6)
            hora_actual = ahora.hour
            
            # Horario operativo: Lunes a Viernes, 6:00 AM a 10:00 PM
            en_horario = not es_fin_semana and 6 <= hora_actual <= 22
            
            if en_horario:
                resultado["criterios"]["horario_operativo"] = True
                resultado["detalles"]["horario"] = f"Horario operativo vÃ¡lido: {ahora.strftime('%A %H:%M')}"
            else:
                if es_fin_semana:
                    resultado["detalles"]["horario"] = f"Fin de semana: {ahora.strftime('%A %H:%M')}"
                    resultado["recomendaciones"].append("Esperar a dÃ­a hÃ¡bil para operar")
                else:
                    resultado["detalles"]["horario"] = f"Fuera de horario operativo: {ahora.strftime('%A %H:%M')}"
                    resultado["recomendaciones"].append("Operar entre 6:00 AM y 10:00 PM")
            
            # 6. Verificar que no hay bloqueo 403 reciente
            sin_bloqueo = not self._debe_esperar_por_bloqueo_403()
            if sin_bloqueo:
                resultado["criterios"]["sin_bloqueo_403"] = True
                resultado["detalles"]["bloqueo_403"] = "Sin bloqueos recientes"
            else:
                tiempo_restante = self._tiempo_restante_bloqueo_403()
                resultado["detalles"]["bloqueo_403"] = f"Bloqueo 403 activo, {tiempo_restante//60} min restantes"
                resultado["recomendaciones"].append(f"Esperar {tiempo_restante//60} minutos antes de operar")
            
            # Determinar estado final
            todos_criterios = all(resultado["criterios"].values())
            resultado["listo"] = todos_criterios
            
            # Mensaje de estado
            if resultado["listo"]:
                resultado["mensaje"] = "âœ… Bot completamente listo para ejecutar estrategias"
            else:
                criterios_faltantes = [k for k, v in resultado["criterios"].items() if not v]
                resultado["mensaje"] = f"âš ï¸ Faltan criterios: {', '.join(criterios_faltantes)}"
            
        except Exception as e:
            resultado["error"] = str(e)
            resultado["mensaje"] = f"âŒ Error verificando estado: {e}"
            resultado["recomendaciones"].append("Revisar logs para mÃ¡s detalles del error")
        
        return resultado
    
    async def verificar_y_notificar_estado_operativo(self, telegram_bot=None) -> bool:
        """Verifica si el bot estÃ¡ listo para operar y notifica el estado.
        
        Returns:
            bool: True si estÃ¡ listo, False si no
        """
        estado = await self.esta_listo_para_operar()
        
        # Log del estado actual
        if estado["listo"]:
            logger.info(f"âœ… {estado['mensaje']}")
            
            # Mostrar detalles de conexiÃ³n
            for criterio, detalle in estado["detalles"].items():
                logger.info(f"  ðŸ“‹ {criterio}: {detalle}")
            
            # Notificar por Telegram si estÃ¡ disponible
            if telegram_bot:
                try:
                    mensaje_telegram = (
                        f"ðŸŽ¯ **BOT LISTO PARA OPERAR**\n\n"
                        f"â° Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                        f"ðŸ“Š **Estado de Criterios:**\n"
                    )
                    
                    for criterio, cumplido in estado["criterios"].items():
                        emoji = "âœ…" if cumplido else "âŒ"
                        nombre = criterio.replace('_', ' ').title()
                        mensaje_telegram += f"{emoji} {nombre}\n"
                    
                    mensaje_telegram += f"\nðŸ’¡ **Detalles:**\n"
                    for detalle in estado["detalles"].values():
                        mensaje_telegram += f"â€¢ {detalle}\n"
                    
                    await telegram_bot.notificar_admin_telegram(mensaje_telegram)
                except Exception as e:
                    logger.error(f"Error enviando notificaciÃ³n de estado: {e}")
        else:
            logger.warning(f"âš ï¸ {estado['mensaje']}")
            
            # Mostrar criterios faltantes
            criterios_faltantes = [k for k, v in estado["criterios"].items() if not v]
            logger.warning(f"ðŸ“‹ Criterios faltantes: {', '.join(criterios_faltantes)}")
            
            # Mostrar recomendaciones
            if estado["recomendaciones"]:
                logger.info("ðŸ’¡ Recomendaciones:")
                for rec in estado["recomendaciones"]:
                    logger.info(f"  â€¢ {rec}")
            
            # Notificar problemas por Telegram si estÃ¡ disponible
            if telegram_bot:
                try:
                    mensaje_telegram = (
                        f"âš ï¸ **BOT NO LISTO PARA OPERAR**\n\n"
                        f"â° Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                        f"âŒ **Criterios Faltantes:**\n"
                    )
                    
                    for criterio in criterios_faltantes:
                        nombre = criterio.replace('_', ' ').title()
                        mensaje_telegram += f"â€¢ {nombre}\n"
                    
                    if estado["recomendaciones"]:
                        mensaje_telegram += f"\nðŸ’¡ **Recomendaciones:**\n"
                        for rec in estado["recomendaciones"][:3]:  # Limitar a 3 recomendaciones
                            mensaje_telegram += f"â€¢ {rec}\n"
                    
                    await telegram_bot.notificar_admin_telegram(mensaje_telegram)
                except Exception as e:
                    logger.error(f"Error enviando notificaciÃ³n de problemas: {e}")
        
        return estado["listo"]
    
    async def esperar_hasta_estar_listo(self, timeout: int = 300, telegram_bot=None) -> bool:
        """Espera hasta que el bot estÃ© completamente listo para operar.
        
        Args:
            timeout: Tiempo mÃ¡ximo de espera en segundos (default: 5 minutos)
            telegram_bot: Instancia del bot de Telegram para notificaciones
            
        Returns:
            bool: True si estÃ¡ listo, False si se agotÃ³ el timeout
        """
        inicio = datetime.now()
        logger.info(f"ðŸ”„ Esperando hasta que el bot estÃ© listo para operar (timeout: {timeout}s)...")
        
        while (datetime.now() - inicio).total_seconds() < timeout:
            estado = await self.esta_listo_para_operar()
            
            if estado["listo"]:
                logger.info("ðŸŽ‰ Â¡Bot completamente listo para operar!")
                await self.verificar_y_notificar_estado_operativo(telegram_bot)
                return True
            
            # Mostrar progreso cada 30 segundos
            tiempo_transcurrido = (datetime.now() - inicio).total_seconds()
            if int(tiempo_transcurrido) % 30 == 0:
                criterios_ok = sum(estado["criterios"].values())
                total_criterios = len(estado["criterios"])
                logger.info(f"ðŸ“Š Progreso: {criterios_ok}/{total_criterios} criterios cumplidos")
                
                # Mostrar criterio mÃ¡s crÃ­tico faltante
                criterios_faltantes = [k for k, v in estado["criterios"].items() if not v]
                if criterios_faltantes:
                    logger.info(f"â³ Esperando: {criterios_faltantes[0].replace('_', ' ')}")
            
            await asyncio.sleep(5)  # Verificar cada 5 segundos
        
        # Timeout alcanzado
        logger.error(f"â° Timeout: El bot no estuvo listo en {timeout} segundos")
        estado_final = await self.esta_listo_para_operar()
        await self.verificar_y_notificar_estado_operativo(telegram_bot)
        return False

    
    async def obtener_mercados_disponibles(self) -> List[Dict]:
        """
        Obtiene todos los mercados disponibles con payout â‰¥ 80% desde pyquotex.instruments
        """
        try:
            if not self.quotex:
                raise Exception("No hay conexiÃ³n activa a Quotex")
            
            # Obtener instruments desde pyquotex
            if not hasattr(self.quotex, 'instruments') or not self.quotex.instruments:
                print(f"[MarketManager] âš ï¸ No hay instruments disponibles")
                return []
            
            instruments = self.quotex.instruments
            print(f"[MarketManager] ðŸ“Š Procesando {len(instruments)} instrumentos desde pyquotex...")
            
            # Procesar instruments (son listas, no diccionarios)
            # Estructura: [id, symbol, name, type, ?, payout, ?, ?, ?, ?, ?, ?, ?, timestamp, is_open, ...]
            mercados_validos = []
            
            for inst in instruments:
                try:
                    # Extraer datos de la lista
                    instrument_id = inst[0]
                    symbol = inst[1]
                    name = inst[2]
                    asset_type = inst[3]
                    payout = inst[5]  # Payout en posiciÃ³n 5
                    is_open = inst[14] if len(inst) > 14 else True
                    
                    # Filtrar por payout mÃ­nimo
                    if payout < self.payout_minimo:
                        continue
                    
                    # Filtrar solo mercados abiertos
                    if not is_open:
                        continue
                    
                    # Determinar si es OTC
                    otc = '_otc' in symbol.lower() or '(OTC)' in name
                    
                    # Crear objeto de mercado
                    mercado = {
                        'id': instrument_id,
                        'symbol': symbol,
                        'name': name,
                        'type': asset_type,
                        'payout': payout,
                        'otc': otc,
                        'open': is_open
                    }
                    
                    mercados_validos.append(mercado)
                    
                except Exception as e:
                    print(f"[MarketManager] âš ï¸ Error procesando instrumento: {e}")
                    continue
            
            print(f"[MarketManager] âœ… {len(mercados_validos)} mercados con payout â‰¥ {self.payout_minimo}%")
            
            # Mostrar estadÃ­sticas de payouts
            if mercados_validos:
                payouts = [m['payout'] for m in mercados_validos]
                print(f"[MarketManager] ðŸ“Š Rango de payouts: {min(payouts):.0f}% - {max(payouts):.0f}%")
                print(f"[MarketManager] ðŸ’° Payout promedio: {sum(payouts)/len(payouts):.1f}%")
                
                # Mostrar algunos ejemplos
                ejemplos = mercados_validos[:3]
                print(f"[MarketManager] ðŸ“‹ Ejemplos:")
                for m in ejemplos:
                    print(f"   â€¢ {m['name']}: {m['payout']}%")
            
            return mercados_validos
        
        except Exception as e:
            logger.error(f"Error obteniendo mercados disponibles: {e}")
            print(f"[MarketManager] âŒ Error obteniendo mercados: {e}")
            return []

    def _fetch_assets(self) -> List[Dict]:
        """
        Devuelve la lista de activos desde quotexpy, adaptÃ¡ndose a posibles
        diferencias de versiÃ³n (mÃ©todo get_assets, get_all_assets o propiedad assets).
        Nunca lanza excepciÃ³n; en error devuelve [].
        """
        try:
            q = self.quotex
            if not q:
                return []
            # Intento 1: mÃ©todo estÃ¡ndar
            if hasattr(q, 'get_assets'):
                return q.get_assets()
            # Intento 2: alternativas conocidas
            if hasattr(q, 'get_all_assets'):
                return q.get_all_assets()
            # Intento 3: propiedad/atributo
            if hasattr(q, 'assets'):
                assets = getattr(q, 'assets')
                return assets() if callable(assets) else assets
        except Exception as e:
            print(f"[MarketManager] âŒ Error adaptando mÃ©todo de activos: {e}")
        return []
    
    def cargar_horarios_noticias(self) -> Dict:
        """
        Carga los horarios de noticias importantes para cada mercado
        """
        return {
            "EURUSD": [
                {"hora": "08:30", "descripcion": "Datos econÃ³micos EUR"},
                {"hora": "14:30", "descripcion": "Datos econÃ³micos USD"},
                {"hora": "16:00", "descripcion": "Fed/ECB announcements"}
            ],
            "GBPUSD": [
                {"hora": "07:00", "descripcion": "UK Economic Data"},
                {"hora": "14:30", "descripcion": "US Economic Data"}
            ],
            "USDJPY": [
                {"hora": "14:30", "descripcion": "US Economic Data"},
                {"hora": "23:50", "descripcion": "Japan Economic Data"}
            ],
            "GOLD": [
                {"hora": "14:30", "descripcion": "US Economic Data"},
                {"hora": "16:00", "descripcion": "Fed Announcements"}
            ],
            "BTC": [],  # Crypto no tiene horarios de noticias tradicionales
            "ETH": []
        }

    
    def esta_en_horario_noticias(self, symbol: str) -> bool:
        """
        Verifica si un mercado estÃ¡ en horario de noticias importantes
        """
        ahora = datetime.now()
        hora_actual = ahora.strftime("%H:%M")
        
        # Limpiar sÃ­mbolo (quitar _otc si existe)
        symbol_base = symbol.replace("_otc", "")
        
        if symbol_base not in self.horarios_noticias:
            return False
        
        # Verificar si estamos dentro de Â±30 minutos de alguna noticia
        for noticia in self.horarios_noticias[symbol_base]:
            hora_noticia = datetime.strptime(noticia["hora"], "%H:%M").time()
            hora_actual_dt = datetime.strptime(hora_actual, "%H:%M").time()
            
            # Convertir a minutos para comparar
            minutos_noticia = hora_noticia.hour * 60 + hora_noticia.minute
            minutos_actual = hora_actual_dt.hour * 60 + hora_actual_dt.minute
            
            # Si estamos dentro de Â±30 minutos de la noticia
            if abs(minutos_actual - minutos_noticia) <= 30:
                print(f"[MarketManager] âš ï¸ {symbol} en horario de noticias: {noticia['descripcion']}")
                return True
        
        return False
    
    def seleccionar_mercados_para_analizar(self, payout_minimo: float = 80.0) -> List[Dict]:
        """
        Selecciona quÃ© mercados analizar segÃºn las condiciones:
        - DespuÃ©s de 4:00 PM: SOLO mercados OTC (mercados normales cerrados)
        - SÃ¡bados: SOLO mercados OTC (mercados normales cerrados)
        - En horario de noticias: SOLO mercados OTC
        - Fuera de horario de noticias: normales y OTC
        - FILTRO: Solo mercados con payout >= payout_minimo (default 80%)
        """
        from datetime import datetime
        
        mercados_para_analizar = []
        # Los mercados ya se cargan automÃ¡ticamente al conectar
        if not self.mercados_disponibles:
            print(f"[MarketManager] âš ï¸ No hay mercados cargados. Esperando conexiÃ³n a Quotex...")
            return []

        # Obtener hora actual
        ahora = datetime.now()
        hora_actual = ahora.hour
        
        # NUEVA REGLA: DespuÃ©s de 4:00 PM (16:00), solo OTC
        if hora_actual >= 16:
            # SOLO mercados OTC (sin agregar normales)
            mercados_para_analizar = self.mercados_otc.copy()
            print(f"[MarketManager] ðŸŒ™ DespuÃ©s de 4:00 PM: solo mercados OTC seleccionados ({len(mercados_para_analizar)} mercados)")
            print(f"[MarketManager] â„¹ï¸ Mercados normales cerrados - OTC tienen mejores payouts en este horario")
        
        # Verificar si es sÃ¡bado (weekday = 5)
        es_sabado = ahora.weekday() == 5
        
        if es_sabado:
            # Los sÃ¡bados solo mercados OTC (mercados normales cerrados)
            mercados_para_analizar = self.mercados_otc.copy()
            print(f"[MarketManager] ðŸ“… SÃ¡bado: solo mercados OTC seleccionados ({len(mercados_para_analizar)} mercados - mercados normales cerrados)")
        else:
            # Detectar si estamos en horario de noticias para algÃºn mercado normal
            en_horario_noticias = any(
                self.esta_en_horario_noticias(m["symbol"]) for m in self.mercados_disponibles
            )

            if en_horario_noticias:
                # Solo mercados OTC durante horario de noticias (alta volatilidad en normales)
                mercados_para_analizar = self.mercados_otc.copy()
                print(f"[MarketManager] ðŸš¨ Horario de noticias: solo mercados OTC seleccionados ({len(mercados_para_analizar)} mercados - evitando alta volatilidad)")
            else:
                # Todos los mercados disponibles (normales y OTC)
                mercados_para_analizar = self.mercados_disponibles.copy() + self.mercados_otc.copy()
                print(f"[MarketManager] âœ… No hay noticias: todos los mercados seleccionados")
        
        # FILTRO: Solo mercados con payout >= payout_minimo
        mercados_antes = len(mercados_para_analizar)
        mercados_para_analizar = [m for m in mercados_para_analizar if m.get('payout', 0) >= payout_minimo]
        mercados_despues = len(mercados_para_analizar)
        
        if mercados_antes > mercados_despues:
            print(f"[MarketManager] ðŸ’° Filtro de payout â‰¥{payout_minimo}%: {mercados_antes} â†’ {mercados_despues} mercados")
        
        print(f"[MarketManager] âœ… Total mercados seleccionados: {len(mercados_para_analizar)}")
        return mercados_para_analizar
    
    def analizar_efectividad_diaria_mercado(self, symbol: str, df: pd.DataFrame) -> float:
                    print(f"[MarketManager] ðŸ“¦ Tipo de payment_data: {type(payment_data)}")
                    if isinstance(payment_data, dict) and len(payment_data) > 0:
                        # Mostrar ejemplo de un mercado
                        primer_mercado = list(payment_data.items())[0]
                        print(f"[MarketManager] ðŸ“‹ Ejemplo de mercado: {primer_mercado[0]}")
                        print(f"[MarketManager] ðŸ“‹ Estructura: {primer_mercado[1]}")
                    
                    if isinstance(payment_data, dict):
                        # payment_data = {"Cardano (OTC)": {"payment": 89, "profit": {"5M": 87}, "open": True}}
                        for symbol_name, data in payment_data.items():
                            if isinstance(data, dict):
                                # Obtener payout para operaciones de 5 minutos (nuestro caso)
                                payout_value = None
                                
                                # Prioridad 1: profit['5M'] (payout especÃ­fico para 5 minutos)
                                if 'profit' in data and isinstance(data['profit'], dict) and '5M' in data['profit']:
                                    payout_value = data['profit']['5M']
                                # Prioridad 2: payment (payout general)
                                elif 'payment' in data:
                                    payout_value = data['payment']
                                # Prioridad 3: turbo_payment
                                elif 'turbo_payment' in data:
                                    payout_value = data['turbo_payment']
                                
                                if payout_value is not None and isinstance(payout_value, (int, float)):
                                    # Si es decimal (0.85), convertir a porcentaje
                                    if payout_value < 1:
                                        payout_value = payout_value * 100
                                    
                                    payout_info = {
                                        'payout': round(payout_value, 1),
                                        'open': data.get('open', True),
                                        'turbo_payout': data.get('turbo_payment', payout_value),
                                        'profit_5m': data.get('profit', {}).get('5M', payout_value) if isinstance(data.get('profit'), dict) else payout_value
                                    }
                                    
                                    # Guardar con nombre completo
                                    payouts_reales[symbol_name] = payout_info
                                    
                                    # Crear mapeo adicional por sÃ­mbolo limpio
                                    # "Cardano (OTC)" -> "ADAUSD"
                                    # "EUR/USD" -> "EURUSD"
                                    symbol_clean = symbol_name.replace(' (OTC)', '').replace('/', '').replace(' ', '').upper()
                                    payouts_por_simbolo[symbol_clean] = payout_info
                        
                        logger.info(f"[MarketManager] âœ… Payouts reales obtenidos: {len(payouts_reales)} mercados")
                        print(f"[MarketManager] ðŸ’° Payouts reales cargados para {len(payouts_reales)} mercados")
                        
                        # Mostrar rango de payouts
                        if payouts_reales:
                            payouts_valores = [p['payout'] for p in payouts_reales.values()]
                            print(f"[MarketManager] ðŸ“Š Rango de payouts: {min(payouts_valores):.0f}% - {max(payouts_valores):.0f}%")
                            
                            # DEBUG: Mostrar algunos ejemplos
                            ejemplos = list(payouts_reales.items())[:3]
                            print(f"[MarketManager] ðŸ“‹ Ejemplos de payouts:")
                            for nombre, info in ejemplos:
                                print(f"   â€¢ {nombre}: {info['payout']}%")
                            
                            # EstadÃ­sticas adicionales de payouts
                            payouts_altos = [p for p in payouts_valores if p >= 85]
                            payouts_medios = [p for p in payouts_valores if 80 <= p < 85]
                            payouts_bajos = [p for p in payouts_valores if p < 80]
                            print(f"[MarketManager] ðŸ“ˆ DistribuciÃ³n de payouts:")
                            print(f"   â€¢ â‰¥85%: {len(payouts_altos)} mercados")
                            print(f"   â€¢ 80-85%: {len(payouts_medios)} mercados")
                            print(f"   â€¢ <80%: {len(payouts_bajos)} mercados (serÃ¡n filtrados)")
                    else:
                        print(f"[MarketManager] âš ï¸ payment_data no es dict, tipo: {type(payment_data)}")
                else:
                    print(f"[MarketManager] âš ï¸ No se pudo obtener payment_data de ninguna fuente")
                    print(f"[MarketManager] ðŸ“‹ MÃ©todos disponibles en quotex: {[m for m in dir(self.quotex) if 'payment' in m.lower()]}")
            except Exception as e:
                import traceback
                logger.warning(f"[MarketManager] âš ï¸ No se pudieron obtener payouts reales: {e}")
                print(f"[MarketManager] âš ï¸ Error obteniendo payouts: {e}")
                print(f"[MarketManager] ðŸ“‹ Traceback: {traceback.format_exc()[:500]}")
            
            # Obtener activos de forma asÃ­ncrona
            # Primero intentar obtener datos completos con payout
            mercados_api = None
            
            # Obtener activos disponibles
            if hasattr(self.quotex, 'assets_data') and self.quotex.assets_data:
                mercados_api = self.quotex.assets_data
            elif hasattr(self.quotex, 'api') and hasattr(self.quotex.api, 'assets_data') and self.quotex.api.assets_data:
                mercados_api = self.quotex.api.assets_data
            elif hasattr(self.quotex, 'assets') and self.quotex.assets:
                mercados_api = self.quotex.assets
            elif hasattr(self.quotex, 'api') and hasattr(self.quotex.api, 'assets') and self.quotex.api.assets:
                mercados_api = self.quotex.api.assets
            elif hasattr(self.quotex, 'get_all_assets'):
                mercados_api = await self.quotex.get_all_assets()
            elif hasattr(self.quotex, 'get_assets'):
                mercados_api = await self.quotex.get_assets()
            else:
                raise Exception("MÃ©todo de activos no disponible")
            
            # Verificar el formato de los datos
            if not mercados_api or not isinstance(mercados_api, (list, dict)):
                print(f"[MarketManager] âš ï¸ Formato inesperado de activos: {type(mercados_api)}")
                return []
            
            # Si es un diccionario, verificar su estructura
            if isinstance(mercados_api, dict):
                if mercados_api:
                    primer_valor = list(mercados_api.values())[0]
                
                # CASO 1: Si es {symbol: id}, crear mercados con payout real o por defecto
                if isinstance(primer_valor, int):
                    mercados_validos = []
                    
                    # Crear mercados usando payouts reales cuando estÃ©n disponibles
                    for symbol, asset_id in mercados_api.items():
                        otc = '_otc' in symbol.lower()
                        symbol_clean = symbol.replace('_otc', '').replace('_OTC', '').upper()
                        
                        # Buscar payout real para este sÃ­mbolo
                        payout_real = None
                        is_open = True
                        payout_encontrado = False
                        
                        # Estrategia 1: Buscar por sÃ­mbolo exacto
                        if symbol in payouts_reales:
                            payout_real = payouts_reales[symbol]['payout']
                            is_open = payouts_reales[symbol]['open']
                            payout_encontrado = True
                        # Estrategia 2: Buscar por sÃ­mbolo limpio
                        elif symbol_clean in payouts_reales:
                            payout_real = payouts_reales[symbol_clean]['payout']
                            is_open = payouts_reales[symbol_clean]['open']
                            payout_encontrado = True
                        # Estrategia 3: Buscar en payouts_por_simbolo
                        elif symbol in payouts_por_simbolo:
                            payout_real = payouts_por_simbolo[symbol]['payout']
                            is_open = payouts_por_simbolo[symbol]['open']
                            payout_encontrado = True
                        elif symbol_clean in payouts_por_simbolo:
                            payout_real = payouts_por_simbolo[symbol_clean]['payout']
                            is_open = payouts_por_simbolo[symbol_clean]['open']
                            payout_encontrado = True
                        # Estrategia 4: Buscar con variaciones del nombre
                        else:
                            # Intentar con variaciones: EURUSD, EUR/USD, EUR-USD
                            variaciones = [
                                symbol_clean,
                                symbol_clean.replace('/', ''),
                                symbol_clean.replace('-', ''),
                                f"{symbol_clean[:3]}/{symbol_clean[3:]}",
                                f"{symbol_clean[:3]}-{symbol_clean[3:]}"
                            ]
                            
                            for variacion in variaciones:
                                if variacion in payouts_reales:
                                    payout_real = payouts_reales[variacion]['payout']
                                    is_open = payouts_reales[variacion]['open']
                                    payout_encontrado = True
                                    break
                                elif variacion in payouts_por_simbolo:
                                    payout_real = payouts_por_simbolo[variacion]['payout']
                                    is_open = payouts_por_simbolo[variacion]['open']
                                    payout_encontrado = True
                                    break
                        
                        # Si no se encontrÃ³ payout real, usar valor por defecto
                        if not payout_encontrado:
                            payout_real = 85  # Valor conservador por defecto
                            logger.warning(f"[MarketManager] âš ï¸ Payout no encontrado para {symbol}, usando {payout_real}% por defecto")
                        else:
                            logger.debug(f"[MarketManager] âœ… Payout encontrado para {symbol}: {payout_real}%")
                        
                        # IMPORTANTE: Guardar el sÃ­mbolo ORIGINAL (con _OTC si aplica)
                        mercados_validos.append({
                            "symbol": symbol,  # âœ… SÃ­mbolo ORIGINAL con _OTC
                            "payout": payout_real,  # Payout REAL de Quotex
                            "type": "crypto" if any(x in symbol_clean for x in ['BTC', 'ETH', 'USD']) else "forex",
                            "otc": otc,
                            "nombre": symbol_clean,  # Nombre limpio para mostrar
                            "asset_id": asset_id,
                            "open": is_open
                        })
                    
                    # Filtrar solo mercados con payout >= 80%
                    mercados_validos = [m for m in mercados_validos if m["payout"] >= 80]
                    
                    self.mercados_disponibles = [m for m in mercados_validos if not m["otc"]]
                    self.mercados_otc = [m for m in mercados_validos if m["otc"]]
                    
                    # Calcular estadÃ­sticas de payout
                    if mercados_validos:
                        payouts = [m["payout"] for m in mercados_validos]
                        payout_min = min(payouts)
                        payout_max = max(payouts)
                        payout_avg = sum(payouts) / len(payouts)
                        print(f"[MarketManager] ðŸ“Š Mercados normales: {len(self.mercados_disponibles)} | OTC: {len(self.mercados_otc)}")
                        print(f"[MarketManager] ðŸ’° Payout: Min={payout_min:.1f}% | Max={payout_max:.1f}% | Avg={payout_avg:.1f}%")
                        print(f"[MarketManager] âœ… Filtrado: Solo mercados con payout â‰¥ 80%")
                        
                        # Mostrar algunos ejemplos de sÃ­mbolos OTC para verificar
                        if self.mercados_otc:
                            ejemplos_otc = [m['symbol'] for m in self.mercados_otc[:5]]
                            print(f"[MarketManager] ðŸ“‹ Ejemplos OTC: {', '.join(ejemplos_otc)}")
                    else:
                        print(f"[MarketManager] ðŸ“Š Mercados normales: {len(self.mercados_disponibles)} | OTC: {len(self.mercados_otc)}")
                    return mercados_validos
                
                # CASO 2: Puede ser {symbol: data} o {'assets': [...]}
                if 'assets' in mercados_api:
                    mercados_api = mercados_api['assets']
                else:
                    mercados_api = list(mercados_api.values())
            
            mercados_validos = []
            
            # Procesamiento normal si los datos tienen estructura completa (ya no deberÃ­a llegar aquÃ­ con {symbol: id})
            if isinstance(mercados_api, dict) and mercados_api:
                primer_valor = list(mercados_api.values())[0]
                if isinstance(primer_valor, int):
                    # Es un mapeo {symbol: id}, usar payouts reales si estÃ¡n disponibles
                    if payouts_reales:
                        print(f"[MarketManager] âœ… Usando payouts REALES de Quotex")
                    else:
                        print(f"[MarketManager] â„¹ï¸ Usando payout por defecto (90%) para todos los mercados")
                    
                    for symbol, asset_id in mercados_api.items():
                        otc = '_otc' in symbol.lower()
                        symbol_clean = symbol.replace('_otc', '').replace('_OTC', '')
                        
                        # Buscar payout real
                        payout_real = 90  # Valor por defecto
                        is_open = True
                        
                        if symbol in payouts_reales:
                            payout_real = payouts_reales[symbol]['payout']
                            is_open = payouts_reales[symbol]['open']
                        elif symbol_clean in payouts_reales:
                            payout_real = payouts_reales[symbol_clean]['payout']
                            is_open = payouts_reales[symbol_clean]['open']
                        elif symbol in payouts_por_simbolo:
                            payout_real = payouts_por_simbolo[symbol]['payout']
                            is_open = payouts_por_simbolo[symbol]['open']
                        elif symbol_clean in payouts_por_simbolo:
                            payout_real = payouts_por_simbolo[symbol_clean]['payout']
                            is_open = payouts_por_simbolo[symbol_clean]['open']
                        
                        # IMPORTANTE: Guardar el sÃ­mbolo ORIGINAL (con _OTC si aplica)
                        # para que Quotex pueda obtener los datos correctamente
                        mercados_validos.append({
                            "symbol": symbol,  # âœ… SÃ­mbolo ORIGINAL con _OTC
                            "payout": payout_real,  # Payout REAL
                            "type": "crypto" if any(x in symbol_clean for x in ['BTC', 'ETH', 'USD']) else "forex",
                            "otc": otc,
                            "nombre": symbol_clean,  # Nombre limpio para mostrar
                            "asset_id": asset_id,
                            "open": is_open
                        })
                    self.mercados_disponibles = [m for m in mercados_validos if not m["otc"]]
                    self.mercados_otc = [m for m in mercados_validos if m["otc"]]
                    print(f"[MarketManager] ðŸ“Š Mercados normales encontrados: {len(self.mercados_disponibles)}")
                    print(f"[MarketManager] ðŸ”„ Mercados OTC encontrados: {len(self.mercados_otc)}")
                    
                    # Mostrar algunos ejemplos de sÃ­mbolos OTC para verificar
                    if self.mercados_otc:
                        ejemplos_otc = [m['symbol'] for m in self.mercados_otc[:5]]
                        print(f"[MarketManager] ðŸ“‹ Ejemplos OTC: {', '.join(ejemplos_otc)}")
                    
                    return mercados_validos
            
            # Procesamiento normal si los datos tienen estructura completa
            for m in mercados_api:
                # Si m es un string (solo el sÃ­mbolo), saltar
                if isinstance(m, str):
                    continue
                if not isinstance(m, dict):
                    continue
                
                symbol = m.get('symbol', '')
                tipo = m.get('type', 'forex')
                otc = m.get('otc', False)
                
                # Intentar obtener payout real primero
                payout = 90  # Por defecto
                is_open = True
                
                if symbol in payouts_reales:
                    payout = payouts_reales[symbol]['payout']
                    is_open = payouts_reales[symbol]['open']
                elif symbol in payouts_por_simbolo:
                    payout = payouts_por_simbolo[symbol]['payout']
                    is_open = payouts_por_simbolo[symbol]['open']
                else:
                    # Fallback a profit_percentage del mercado
                    payout = m.get('profit_percentage', 90)
                
                if payout >= 80:
                    # Si es OTC y el sÃ­mbolo no tiene el sufijo, agregarlo
                    symbol_final = symbol
                    if otc and '_otc' not in symbol.lower():
                        symbol_final = f"{symbol}_OTC"
                    
                    mercados_validos.append({
                        "symbol": symbol_final,  # âœ… Con _OTC si aplica
                        "payout": payout,
                        "type": tipo,
                        "otc": otc,
                        "nombre": m.get('name', symbol),
                        "open": is_open
                    })
            self.mercados_disponibles = [m for m in mercados_validos if not m["otc"]]
            self.mercados_otc = [m for m in mercados_validos if m["otc"]]
            print(f"[MarketManager] ðŸ“Š Mercados normales encontrados: {len(self.mercados_disponibles)}")
            print(f"[MarketManager] ðŸ”„ Mercados OTC encontrados: {len(self.mercados_otc)}")
            
            # Mostrar algunos ejemplos de sÃ­mbolos OTC para verificar
            if self.mercados_otc:
                ejemplos_otc = [m['symbol'] for m in self.mercados_otc[:5]]
                print(f"[MarketManager] ðŸ“‹ Ejemplos OTC: {', '.join(ejemplos_otc)}")
            
            return mercados_validos
        except Exception as e:
            print(f"[MarketManager] âŒ Error obteniendo mercados: {e}")
            return []

    def _fetch_assets(self) -> List[Dict]:
        """
        Devuelve la lista de activos desde quotexpy, adaptÃ¡ndose a posibles
        diferencias de versiÃ³n (mÃ©todo get_assets, get_all_assets o propiedad assets).
        Nunca lanza excepciÃ³n; en error devuelve [].
        """
        try:
            q = self.quotex
            if not q:
                return []
            # Intento 1: mÃ©todo estÃ¡ndar
            if hasattr(q, 'get_assets'):
                return q.get_assets()
            # Intento 2: alternativas conocidas
            if hasattr(q, 'get_all_assets'):
                return q.get_all_assets()
            # Intento 3: propiedad/atributo
            if hasattr(q, 'assets'):
                assets = getattr(q, 'assets')
                return assets() if callable(assets) else assets
        except Exception as e:
            print(f"[MarketManager] âŒ Error adaptando mÃ©todo de activos: {e}")
        return []
    
    def cargar_horarios_noticias(self) -> Dict:
        """
        Carga los horarios de noticias importantes para cada mercado
        """
        return {
            "EURUSD": [
                {"hora": "08:30", "descripcion": "Datos econÃ³micos EUR"},
                {"hora": "14:30", "descripcion": "Datos econÃ³micos USD"},
                {"hora": "16:00", "descripcion": "Fed/ECB announcements"}
            ],
            "GBPUSD": [
                {"hora": "07:00", "descripcion": "UK Economic Data"},
                {"hora": "14:30", "descripcion": "US Economic Data"}
            ],
            "USDJPY": [
                {"hora": "14:30", "descripcion": "US Economic Data"},
                {"hora": "23:50", "descripcion": "Japan Economic Data"}
            ],
            "GOLD": [
                {"hora": "14:30", "descripcion": "US Economic Data"},
                {"hora": "16:00", "descripcion": "Fed Announcements"}
            ],
            "BTC": [],  # Crypto no tiene horarios de noticias tradicionales
            "ETH": []
        }

    
    def esta_en_horario_noticias(self, symbol: str) -> bool:
        """
        Verifica si un mercado estÃ¡ en horario de noticias importantes
        """
        ahora = datetime.now()
        hora_actual = ahora.strftime("%H:%M")
        
        # Limpiar sÃ­mbolo (quitar _otc si existe)
        symbol_base = symbol.replace("_otc", "")
        
        if symbol_base not in self.horarios_noticias:
            return False
        
        # Verificar si estamos dentro de Â±30 minutos de alguna noticia
        for noticia in self.horarios_noticias[symbol_base]:
            hora_noticia = datetime.strptime(noticia["hora"], "%H:%M").time()
            hora_actual_dt = datetime.strptime(hora_actual, "%H:%M").time()
            
            # Convertir a minutos para comparar
            minutos_noticia = hora_noticia.hour * 60 + hora_noticia.minute
            minutos_actual = hora_actual_dt.hour * 60 + hora_actual_dt.minute
            
            # Si estamos dentro de Â±30 minutos de la noticia
            if abs(minutos_actual - minutos_noticia) <= 30:
                print(f"[MarketManager] âš ï¸ {symbol} en horario de noticias: {noticia['descripcion']}")
                return True
        
        return False
    
    def seleccionar_mercados_para_analizar(self, payout_minimo: float = 80.0) -> List[Dict]:
        """
        Selecciona quÃ© mercados analizar segÃºn las condiciones:
        - DespuÃ©s de 4:00 PM: SOLO mercados OTC (mercados normales cerrados)
        - SÃ¡bados: SOLO mercados OTC (mercados normales cerrados)
        - En horario de noticias: SOLO mercados OTC
        - Fuera de horario de noticias: normales y OTC
        - FILTRO: Solo mercados con payout >= payout_minimo (default 80%)
        """
        from datetime import datetime
        
        mercados_para_analizar = []
        # Los mercados ya se cargan automÃ¡ticamente al conectar
        if not self.mercados_disponibles:
            print(f"[MarketManager] âš ï¸ No hay mercados cargados. Esperando conexiÃ³n a Quotex...")
            return []

        # Obtener hora actual
        ahora = datetime.now()
        hora_actual = ahora.hour
        
        # NUEVA REGLA: DespuÃ©s de 4:00 PM (16:00), solo OTC
        if hora_actual >= 16:
            # SOLO mercados OTC (sin agregar normales)
            mercados_para_analizar = self.mercados_otc.copy()
            print(f"[MarketManager] ðŸŒ™ DespuÃ©s de 4:00 PM: solo mercados OTC seleccionados ({len(mercados_para_analizar)} mercados)")
            print(f"[MarketManager] â„¹ï¸ Mercados normales cerrados - OTC tienen mejores payouts en este horario")
        
        # Verificar si es sÃ¡bado (weekday = 5)
        es_sabado = ahora.weekday() == 5
        
        if es_sabado:
            # Los sÃ¡bados solo mercados OTC (mercados normales cerrados)
            mercados_para_analizar = self.mercados_otc.copy()
            print(f"[MarketManager] ðŸ“… SÃ¡bado: solo mercados OTC seleccionados ({len(mercados_para_analizar)} mercados - mercados normales cerrados)")
        else:
            # Detectar si estamos en horario de noticias para algÃºn mercado normal
            en_horario_noticias = any(
                self.esta_en_horario_noticias(m["symbol"]) for m in self.mercados_disponibles
            )

            if en_horario_noticias:
                # Solo mercados OTC durante horario de noticias (alta volatilidad en normales)
                mercados_para_analizar = self.mercados_otc.copy()
                print(f"[MarketManager] ðŸš¨ Horario de noticias: solo mercados OTC seleccionados ({len(mercados_para_analizar)} mercados - evitando alta volatilidad)")
            else:
                # Todos los mercados disponibles (normales y OTC)
                mercados_para_analizar = self.mercados_disponibles.copy() + self.mercados_otc.copy()
                print(f"[MarketManager] âœ… No hay noticias: todos los mercados seleccionados")
        
        # FILTRO: Solo mercados con payout >= payout_minimo
        mercados_antes = len(mercados_para_analizar)
        mercados_para_analizar = [m for m in mercados_para_analizar if m.get('payout', 0) >= payout_minimo]
        mercados_despues = len(mercados_para_analizar)
        
        if mercados_antes > mercados_despues:
            print(f"[MarketManager] ðŸ’° Filtro de payout â‰¥{payout_minimo}%: {mercados_antes} â†’ {mercados_despues} mercados")
        
        print(f"[MarketManager] âœ… Total mercados seleccionados: {len(mercados_para_analizar)}")
        return mercados_para_analizar
    
    def analizar_efectividad_diaria_mercado(self, symbol: str, df: pd.DataFrame) -> float:
        """
        Analiza la efectividad de la estrategia en un mercado especÃ­fico
        usando datos de aproximadamente 1 dÃ­a
        """
        try:
            from src.strategies.evaluar_estrategia_completa import evaluar_estrategia_completa
            
            # ANÃLISIS REAL CON DATOS DE QUOTEX - SIN SIMULACIÃ“N
            efectividades = []
            total_seÃ±ales = 0
            
            # Analizar datos reales en chunks para evaluar efectividad histÃ³rica
            for i in range(0, len(df) - 50, 10):  # Cada 10 velas (50 minutos aprox)
                chunk = df.iloc[i:i+50]
                if len(chunk) >= 20:  # MÃ­nimo de datos necesarios
                    resultado = evaluar_estrategia_completa(chunk, symbol)
                    efectividad = resultado.get('efectividad_total', 0)
                    decision = resultado.get('decision')
                    
                    # Solo contar seÃ±ales vÃ¡lidas con alta efectividad
                    if decision and efectividad >= 80:
                        total_seÃ±ales += 1
                        efectividades.append(efectividad)
                        
                        # NOTA: En producciÃ³n, los resultados reales se obtienen
                        # monitoreando las seÃ±ales enviadas y sus resultados reales
            
            # Calcular efectividad promedio del mercado basado en datos reales
            if efectividades:
                efectividad_promedio = sum(efectividades) / len(efectividades)
                
                # La efectividad se basa en el anÃ¡lisis tÃ©cnico real, no en simulaciÃ³n
                # En producciÃ³n, se complementarÃ¡ con resultados reales de seÃ±ales enviadas
                
                # Guardar en historial
                self.guardar_efectividad_mercado(symbol, efectividad_promedio, efectividad_promedio, total_seÃ±ales)
                
                print(f"[MarketManager] ðŸ“ˆ {symbol}: {efectividad_promedio:.1f}% efectividad tÃ©cnica ({total_seÃ±ales} seÃ±ales vÃ¡lidas)")
                return efectividad_promedio
            else:
                print(f"[MarketManager] âš ï¸ {symbol}: Sin seÃ±ales vÃ¡lidas generadas")
                return 0
                
        except Exception as e:
            print(f"[MarketManager] âŒ Error analizando {symbol}: {e}")
            return 0
    
    # MÃ‰TODO DE SIMULACIÃ“N ELIMINADO - SOLO RESULTADOS REALES
    # Los resultados de seÃ±ales provienen Ãºnicamente de datos reales de Quotex
    
    async def obtener_datos_mercado(self, symbol: str) -> pd.DataFrame:
        """
        Obtiene 300 velas de 5 minutos del mercado especificado usando pyquotex.
        Devuelve un DataFrame con columnas: time, open, high, low, close.
        """
        try:
            if not self.quotex:
                raise Exception("No hay conexiÃ³n activa a Quotex")
            
            # pyquotex usa: get_candles(asset, end_from_time, history_seconds, timeframe)
            # Para 300 velas de 5 minutos: 300 * 5 * 60 = 90000 segundos
            import time
            end_time = int(time.time())
            history_seconds = 300 * 5 * 60  # 90000 segundos = 25 horas
            timeframe = 300  # 5 minutos en segundos
            
            candles = await self.quotex.get_candles(symbol, end_time, history_seconds, timeframe)
            
            if not candles:
                raise Exception(f"No se obtuvieron datos para {symbol}")
            
            # pyquotex retorna lista de diccionarios con estructura diferente
            # Formato esperado: [{'time': timestamp, 'open': x, 'high': x, 'low': x, 'close': x}, ...]
            datos = []
            for c in candles:
                try:
                    open_val = float(c.get('open', 0))
                    high_val = float(c.get('high', 0))
                    low_val = float(c.get('low', 0))
                    close_val = float(c.get('close', 0))
                    
                    # Validar que los datos sean vÃ¡lidos (no ceros ni negativos)
                    if all([open_val > 0, high_val > 0, low_val > 0, close_val > 0]):
                        datos.append({
                            'time': c.get('time', c.get('timestamp', 0)),
                            'open': open_val,
                            'high': high_val,
                            'low': low_val,
                            'close': close_val
                        })
                    else:
                        logger.warning(f"Vela invÃ¡lida descartada para {symbol}: {c}")
                except (ValueError, TypeError) as e:
                    logger.warning(f"Error procesando vela para {symbol}: {e}")
                    continue
            
            if not datos:
                logger.error(f"No se obtuvieron velas vÃ¡lidas para {symbol}")
                return pd.DataFrame()
            
            df = pd.DataFrame(datos)
            logger.info(f"âœ… Obtenidas {len(df)} velas vÃ¡lidas para {symbol}")
            
            # ValidaciÃ³n final del DataFrame
            if len(df) < 50:
                logger.warning(f"âš ï¸ Solo {len(df)} velas para {symbol}, se requieren al menos 50")
                return pd.DataFrame()
            
            return df
            
        except Exception as e:
            logger.error(f"Error obteniendo datos de {symbol}: {e}")
            return pd.DataFrame()
    
    async def seleccionar_mejor_mercado(self) -> Dict:
        """
        Selecciona el mercado con mayor efectividad para operar
        Ejecuta anÃ¡lisis en thread separado para no bloquear el bot de Telegram
        
        OPTIMIZACIÃ“N: Analiza solo 30 mercados aleatorios por ciclo para evitar bloqueos
        """
        mercados_analizados = []
        mercados_para_analizar = self.seleccionar_mercados_para_analizar()
        
        # OPTIMIZACIÃ“N: Analizar solo 30 mercados aleatorios por ciclo
        # Esto reduce el tiempo de anÃ¡lisis de >60s a ~15-20s
        import random
        if len(mercados_para_analizar) > 30:
            mercados_muestra = random.sample(mercados_para_analizar, 30)
            print(f"[MarketManager] ðŸŽ² Analizando 30 mercados aleatorios de {len(mercados_para_analizar)} disponibles")
        else:
            mercados_muestra = mercados_para_analizar
        
        for mercado in mercados_muestra:
            symbol = mercado["symbol"]
            
            # Obtener datos del mercado
            df = await self.obtener_datos_mercado(symbol)
            if df is not None and len(df) >= 100:  # Suficientes datos
                # Ejecutar anÃ¡lisis en thread separado para no bloquear el event loop
                import asyncio
                efectividad = await asyncio.to_thread(
                    self.analizar_efectividad_diaria_mercado, symbol, df
                )
                mercado["efectividad_calculada"] = efectividad
                mercados_analizados.append(mercado)
        
        if mercados_analizados:
            # Filtrar solo mercados con efectividad >= 80%
            mercados_validos = [m for m in mercados_analizados if m["efectividad_calculada"] >= 80]
            
            if mercados_validos:
                # Ordenar por efectividad
                mercados_validos.sort(key=lambda x: x["efectividad_calculada"], reverse=True)
                mejor_mercado = mercados_validos[0]
                
                print(f"[MarketManager] ðŸŽ¯ Mejor mercado seleccionado: {mejor_mercado['symbol']} ({mejor_mercado['efectividad_calculada']:.1f}%)")
                return mejor_mercado
            else:
                print("[MarketManager] âš ï¸ No se encontraron mercados con efectividad >= 80%")
                return None
        else:
            print("[MarketManager] âš ï¸ No se encontraron mercados con suficientes datos")
            return None
    
    def cargar_efectividad_historica(self) -> Dict:
        """Carga el historial de efectividad por mercado"""
        try:
            with open('data/efectividad_mercados.json', 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
    
    def guardar_efectividad_mercado(self, symbol: str, efectividad: float, tasa_exito: float, total_seÃ±ales: int):
        """Guarda la efectividad de un mercado"""
        fecha = datetime.now().strftime('%Y-%m-%d')
        
        if symbol not in self.efectividad_historica:
            self.efectividad_historica[symbol] = {}
        
        self.efectividad_historica[symbol][fecha] = {
            'efectividad': efectividad,
            'tasa_exito': tasa_exito,
            'total_seÃ±ales': total_seÃ±ales,
            'timestamp': datetime.now().isoformat()
        }
        
        # Crear directorio si no existe
        os.makedirs('data', exist_ok=True)
        
        # Guardar en archivo
        with open('data/efectividad_mercados.json', 'w') as f:
            json.dump(self.efectividad_historica, f, indent=4)

# FunciÃ³n principal para usar el manager
async def obtener_mejor_mercado_del_dia(email: str, password: str) -> Dict:
    """
    FunciÃ³n principal que devuelve el mejor mercado para operar hoy
    """
    manager = MarketManager()
    
    if await manager.conectar_quotex(email, password):
        return manager.seleccionar_mejor_mercado()
    else:
        return None

if __name__ == "__main__":
    # Prueba del sistema
    mejor_mercado = obtener_mejor_mercado_del_dia("ijroyquotex@gmail.com", "Yorji.050212")
    if mejor_mercado:
        print(f"\nðŸŽ¯ MERCADO SELECCIONADO: {mejor_mercado['symbol']}")
        print(f"ðŸ’° Payout: {mejor_mercado['payout']}%")
        print(f"ðŸ“Š Efectividad estimada: {mejor_mercado['efectividad_calculada']:.1f}%")
    else:
        print("\nâŒ No se pudo seleccionar mercado")
