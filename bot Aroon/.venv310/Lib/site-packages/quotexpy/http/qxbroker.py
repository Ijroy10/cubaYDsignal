import re
import json
import time
import pickle
import requests
from pathlib import Path
from bs4 import BeautifulSoup
from typing import Tuple, Any
import undetected_chromedriver as uc
from quotexpy.exceptions import QuotexAuthError


class Browser(object):
    email = None
    password = None
    on_ping_code = None
    headless = None

    base_url = "qxbroker.com"
    https_base_url = f"https://{base_url}"

    def __init__(self, api):
        self.api = api

    def get_cookies_and_ssid(self) -> Tuple[Any, str]:
        try:
            self.browser = uc.Chrome(headless=self.headless, use_subprocess=False)
        except TypeError as exc:
            raise SystemError("Chrome is not installed, did you forget?") from exc
        self.browser.get(f"{self.https_base_url}/en/sign-in")
        if self.browser.current_url != f"{self.https_base_url}/en/trade":
            # Robust login: esperar inputs VISIBLES/CLICKABLE, manejar banners y overlays
            from selenium.webdriver.common.by import By as _By
            from selenium.webdriver.support.ui import WebDriverWait as _Wait
            from selenium.webdriver.support import expected_conditions as _EC
            from selenium.webdriver import ActionChains as _Actions
            _wait = _Wait(self.browser, 35)

            # Helpers
            def _first_or_none(funcs):
                for f in funcs:
                    try:
                        el = f()
                        if el is not None:
                            return el
                    except Exception:
                        continue
                return None

            def _find_any_by_selectors(selectors):
                # selectors: list of (by, value)
                for by, sel in selectors:
                    try:
                        el = self.browser.find_element(by, sel)
                        if el and el.is_displayed():
                            return el
                    except Exception:
                        continue
                return None

            def _save_login_artifacts(tag="login_fail"):
                try:
                    import os, datetime
                    os.makedirs("logs", exist_ok=True)
                    ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                    path_png = f"logs/{tag}_{ts}.png"
                    path_html = f"logs/{tag}_{ts}.html"
                    try:
                        self.browser.save_screenshot(path_png)
                    except Exception:
                        pass
                    try:
                        with open(path_html, "w", encoding="utf-8") as f:
                            f.write(self.browser.page_source)
                    except Exception:
                        pass
                except Exception:
                    pass

            # Intentar cerrar banners de cookies/overlays comunes
            try:
                # Válidos: CSS o XPATH (evitar :contains en CSS, no soportado por Selenium)
                cookie_candidates = []
                cookie_candidates.append(_first_or_none([
                    lambda: self.browser.find_element(_By.ID, "onetrust-accept-btn-handler"),
                    lambda: self.browser.find_element(_By.CSS_SELECTOR, "#onetrust-accept-btn-handler"),
                ]))
                # XPaths por texto visible
                for xp in [
                    "//button[contains(translate(., 'ACEPTAR', 'aceptar'), 'aceptar')]",
                    "//button[contains(translate(., 'ACCEPT', 'accept'), 'accept')]",
                    "//button[contains(., 'Accept all')]",
                    "//button[contains(., 'Accept All')]",
                    "//button[contains(., 'Aceptar todo')]",
                ]:
                    try:
                        cookie_candidates.append(self.browser.find_element(_By.XPATH, xp))
                    except Exception:
                        pass
                for btn in cookie_candidates:
                    try:
                        if btn and btn.is_displayed():
                            self.browser.execute_script("arguments[0].click();", btn)
                            time.sleep(0.3)
                    except Exception:
                        continue
            except Exception:
                pass

            # Esperar inputs visibles (principal o iframes)
            def _locate_inputs_current_context():
                # Buscar por name/id/type/placeholder/autocomplete
                email_sel = [
                    (_By.CSS_SELECTOR, "input[name='email']"),
                    (_By.CSS_SELECTOR, "input#email"),
                    (_By.CSS_SELECTOR, "input[type='email']"),
                    (_By.XPATH, "//input[@placeholder='Email' or @placeholder='Correo' or contains(translate(@placeholder,'EMAIL','email'),'email')]")
                ]
                pass_sel = [
                    (_By.CSS_SELECTOR, "input[name='password']"),
                    (_By.CSS_SELECTOR, "input#password"),
                    (_By.CSS_SELECTOR, "input[type='password']"),
                    (_By.XPATH, "//input[@placeholder='Password' or @placeholder='Contraseña' or contains(translate(@placeholder,'PASSWORD','password'),'password')]")
                ]
                e = _find_any_by_selectors(email_sel)
                p = _find_any_by_selectors(pass_sel)
                return e, p

            # Intento en documento principal
            email_input, password_input = _locate_inputs_current_context()
            current_frame = None
            # Si no, intentar en iframes
            if not email_input or not password_input:
                try:
                    frames = self.browser.find_elements(_By.TAG_NAME, 'iframe')
                except Exception:
                    frames = []
                for fr in frames or []:
                    try:
                        self.browser.switch_to.frame(fr)
                        e, p = _locate_inputs_current_context()
                        if e and p:
                            email_input, password_input = e, p
                            current_frame = fr
                            break
                    except Exception:
                        pass
                    finally:
                        try:
                            if not (email_input and password_input):
                                self.browser.switch_to.default_content()
                        except Exception:
                            pass
            if not email_input or not password_input:
                _save_login_artifacts("login_no_inputs")
                raise QuotexAuthError("email/password inputs not found (DOM/iframe/anti-bot)")

            # Desplazar a vista y click preliminar para enfocar
            try:
                self.browser.execute_script("arguments[0].scrollIntoView({block:'center'});", email_input)
                _wait.until(_EC.element_to_be_clickable(email_input)).click()
            except Exception:
                pass
            # Escribir email con fallback JS si no interactuable
            try:
                try:
                    email_input.clear()
                except Exception:
                    pass
                email_input.send_keys(self.email)
            except Exception:
                # Fallback JS: set value y disparar eventos input/change
                try:
                    self.browser.execute_script(
                        "arguments[0].value = arguments[1]; arguments[0].dispatchEvent(new Event('input',{bubbles:true})); arguments[0].dispatchEvent(new Event('change',{bubbles:true}));",
                        email_input,
                        self.email,
                    )
                except Exception:
                    pass

            # Password
            try:
                self.browser.execute_script("arguments[0].scrollIntoView({block:'center'});", password_input)
                _wait.until(_EC.element_to_be_clickable(password_input)).click()
            except Exception:
                pass
            try:
                try:
                    password_input.clear()
                except Exception:
                    pass
                password_input.send_keys(self.password)
            except Exception:
                try:
                    self.browser.execute_script(
                        "arguments[0].value = arguments[1]; arguments[0].dispatchEvent(new Event('input',{bubbles:true})); arguments[0].dispatchEvent(new Event('change',{bubbles:true}));",
                        password_input,
                        self.password,
                    )
                except Exception:
                    pass

            # Enviar el formulario
            try:
                # Buscar dentro del contexto actual
                submit_btn = _first_or_none([
                    lambda: self.browser.find_element(_By.XPATH, "//form//button[@type='submit']"),
                    lambda: self.browser.find_element(_By.XPATH, "//button[@type='submit']"),
                    lambda: self.browser.find_element(_By.XPATH, "//form//button[contains(., 'Sign in') or contains(., 'Iniciar') or contains(., 'Entrar') or contains(., 'Acceder')]")
                ])
                if submit_btn.is_displayed():
                    self.browser.execute_script("arguments[0].scrollIntoView({block:'center'});", submit_btn)
                    self.browser.execute_script("arguments[0].click();", submit_btn)
                else:
                    submit_btn.click()
            except Exception:
                try:
                    password_input.submit()
                except Exception:
                    try:
                        self.browser.execute_script(
                            "var f=document.querySelector('form'); if(f){try{f.requestSubmit();}catch(e){f.submit();}}"
                        )
                    except Exception:
                        pass

            time.sleep(5)
            # Diagnóstico si no redirige a /trade
            try:
                if not str(self.browser.current_url).endswith("/trade"):
                    _save_login_artifacts("login_after_submit")
            except Exception:
                pass

        try:
            code_input = self.browser.find_element(uc.By.NAME, "code")
            if code_input.is_displayed():
                code = self.on_ping_code()
                code_input.send_keys(code)
                btn = self.browser.find_element(uc.By.XPATH, "//button[@type='submit']")
                btn.click()
        except:
            pass

        cookies = self.browser.get_cookies()
        self.api.cookies = cookies
        soup = BeautifulSoup(self.browser.page_source, "html.parser")
        user_agent = self.browser.execute_script("return navigator.userAgent;")
        self.api.user_agent = user_agent
        try:
            # Buscar el script que contiene window.settings = ... en vez de depender del índice [1]
            script_tags = soup.find_all("script")
            script_text = None
            for tag in script_tags:
                try:
                    txt = tag.get_text() or ""
                    if "window.settings" in txt:
                        script_text = txt
                        break
                except Exception:
                    continue
            if not script_text:
                raise QuotexAuthError("login succeeded but settings script not found (possibly blocked)")
        except Exception as exc:
            raise QuotexAuthError("incorrect username or password") from exc
        finally:
            self.close()
        # Extraer JSON de window.settings con mayor robustez
        script_clean = script_text.strip()
        if "window.settings" in script_clean:
            script_clean = script_clean.split("window.settings", 1)[1]
        script_clean = script_clean.lstrip(" ").lstrip("=").strip()
        script_clean = script_clean.rstrip(";").strip()
        match = re.sub(r"^\s*", "", script_clean)

        dx: dict = json.loads(match)
        ssid = dx.get("token")

        cookiejar = requests.utils.cookiejar_from_dict({c["name"]: c["value"] for c in cookies})
        cookie_string = "; ".join([f"{c.name}={c.value}" for c in cookiejar])
        output_file = Path(".session.pkl")
        output_file.parent.mkdir(exist_ok=True, parents=True)

        data = {}
        if output_file.is_file():
            with output_file.open("rb") as file:
                data = pickle.load(file)

        data[self.email] = [{"cookies": cookie_string, "ssid": ssid, "user_agent": user_agent}]
        with output_file.open("wb") as file:
            pickle.dump(data, file)

        return ssid, cookie_string

    def close(self):
        try:
            time.sleep(0.2)
            self.browser.close()
        except:
            pass
